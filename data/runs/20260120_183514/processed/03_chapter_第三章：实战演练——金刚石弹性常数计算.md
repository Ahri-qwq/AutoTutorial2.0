# 第三章：实战演练——金刚石弹性常数计算

欢迎来到《ABACUS 实战教程》的核心章节。在前两章中，我们已经熟悉了 ABACUS 的输入文件结构和基础计算流程。本章将不再纸上谈兵，而是通过一个经典的计算材料学案例——**8 原子金刚石（Diamond）超胞**，带你完整复现“生成形变 -> 批量计算 -> 数据拟合”的弹性常数计算标准工作流。

弹性常数（Elastic Constants, $C_{ij}$）是表征材料力学稳定性和刚度的核心参数。对于立方晶系的金刚石，我们需要关注三个独立的弹性常数：$C_{11}, C_{12}, C_{44}$。

> **⚠️ 教授提示**：
> 本章演示的脚本（`gene_dfm.py`, `compute_dfm.py`）并非 ABACUS 内核自带命令，而是源自 ABACUS 用户指南（abacus-user-guide）的辅助 Python 脚本。请确保你已按照前置要求下载了该案例包，并安装了 `pymatgen` 库。

---

## 3.1 生成形变结构 (Pre-processing)

计算弹性常数的本质是模拟胡克定律（Hooke's Law）：$\sigma = C \varepsilon$。我们需要人为地给晶体施加微小的应变（Strain, $\varepsilon$），计算由此产生的应力（Stress, $\sigma$），最后通过线性拟合求出刚度矩阵 $C$。

### 3.1.1 准备完美晶胞
一切计算的起点是一个**完全弛豫（Relaxed）**的结构。在开始形变之前，请务必确保你的金刚石结构（`STRU`）已经经过了高精度的 `cell-relax`，确保初始构型的残余应力接近于零。

### 3.1.2 使用 gene_dfm.py 生成形变
我们将使用 `gene_dfm.py` 脚本自动生成形变结构。该脚本基于 `pymatgen` 库，能够根据晶体的对称性自动施加不同的应变模式。

在案例目录下，运行该脚本通常不需要额外参数（或根据脚本内部设置）：

```bash
python gene_dfm.py
```

**脚本背后的逻辑：**
1.  **读取**：读取完全弛豫后的 `STRU` 文件。
2.  **施加应变**：根据晶体对称性，脚本会生成一组应变模式。对于通用情况，通常会生成 6 种独立的应变模式。
3.  **应变幅值（Magnitude）**：为了保证处于线性弹性区间，应变必须足够小。通常使用的应变幅值 $\delta$ 为：
    *   $\delta \in \{-0.01, -0.005, 0.005, 0.01\}$
4.  **输出**：脚本将生成一系列子文件夹（如 `dfm_0`, `dfm_1` ... `dfm_23`），共计 24 个（6 种模式 $\times$ 4 种幅值）。每个文件夹内都包含了一个发生微小形变后的 `STRU` 文件。

---

## 3.2 核心计算参数配置 (The INPUT)

这是本章**最关键**的部分。90% 的初学者错误都发生在这里。

在形变计算阶段，我们的物理目标是：**保持晶胞形状固定（锁住应变），允许原子内部弛豫，计算此时的静态应力。**

### 3.2.1 关键参数解析

请仔细阅读以下 `INPUT` 文件的核心设置：

```fortran
INPUT_PARAMETERS
# -------------------------------------------
# 1. 任务类型 (CRITICAL)
# -------------------------------------------
calculation     relax      # 必须使用 relax (固定晶胞，弛豫原子)
                           # 严禁使用 cell-relax (否则应变会被释放，前功尽弃！)

# -------------------------------------------
# 2. 力与应力计算
# -------------------------------------------
cal_force       1          # 开启力计算，用于原子弛豫
cal_stress      1          # 开启应力张量计算 (必须开启，否则无法拟合弹性常数)

# -------------------------------------------
# 3. 电子结构优化
# -------------------------------------------
esolver_type    ks         # Kohn-Sham 求解器
basis_type      lcao       # 本案例使用 LCAO 基组 (根据提供的 orb 文件)
ecutwfc         100        # 平面波截断能 (Ry)，需根据赝势测试确定
scf_nmax        100        # SCF 最大迭代步数

# -------------------------------------------
# 4. 离子步弛豫 (原子位置优化)
# -------------------------------------------
relax_nmax      100        # 离子步最大步数
force_thr_ev    0.001      # 力收敛标准 (eV/Angstrom)
mixing_type     broyden    # 电荷密度混合方法，推荐 Broyden 加速收敛
```

### 3.2.2 教授以此为戒：为什么不能用 cell-relax？
如果你在这一步使用了 `calculation cell-relax`，ABACUS 会认为你的目标是消除体系内的应力。因此，程序会改变晶格矢量，把我们辛苦施加的 $\pm 0.01$ 应变全部“优化”掉，最后回到完美的金刚石结构。这样计算出的应力全是零，无法进行拟合。

**记住口诀：先变胞弛豫（准备阶段），再固定晶胞弛豫（形变计算阶段）。**

---

## 3.3 批量任务提交与管理

生成了 24 个文件夹，配置好了 `INPUT` 模板，接下来需要批量运行。手动进入每个文件夹提交任务是不可取的。

### 3.3.1 目录结构设计
标准的目录结构如下所示：
```text
.
├── gene_dfm.py          # 生成脚本
├── compute_dfm.py       # 拟合脚本
├── run_task.sh          # 批量运行脚本
├── INPUT                # 输入参数模板
├── KPT                  # K点设置
├── C_ONCV_PBE-1.0.upf   # 赝势文件
├── C_gga_7au...orb      # 轨道文件
├── dfm_0/               # 形变任务 0
│   └── STRU             # 形变后的结构
├── dfm_1/
│   └── STRU
...
└── dfm_23/
```

### 3.3.2 自动化脚本 (run_task.sh)
我们需要编写一个 Shell 脚本，遍历所有 `dfm_*` 文件夹，将公共文件（INPUT, KPT, 赝势, 轨道）拷贝进去，并执行计算。

参考脚本逻辑（`run_task.sh`）：
```bash
#!/bin/bash

# 遍历所有以 dfm_ 开头的目录
for dir in dfm_*
do
    if [ -d "$dir" ]; then
        echo "Processing $dir..."
        cd $dir
        
        # 拷贝必要文件到子目录
        cp ../INPUT .
        cp ../KPT .
        cp ../*.upf .
        cp ../*.orb .
        
        # 运行 ABACUS (假设可执行文件名为 abacus)
        # 实际使用时建议通过提交作业系统 (如 slurm) 调用 sub.sh
        mpirun -np 4 abacus > running.log 
        
        cd ..
    fi
done
```

运行此脚本后，静待所有任务完成。确保每个子目录下都生成了 `OUT.ABACUS` 文件夹，且日志显示任务正常结束。

---

## 3.4 数据提取与拟合 (Post-processing)

当 24 个计算任务全部完成后，我们进入最后一步：提取数据并计算 $C_{ij}$。

### 3.4.1 使用 compute_dfm.py
该脚本会自动遍历所有子文件夹，从输出文件中提取应力张量（Stress Tensor）和对应的应变张量（Strain Tensor）。

在根目录下运行：
```bash
python compute_dfm.py
```

### 3.4.2 拟合原理与结果解读
脚本内部调用 `pymatgen` 的 `ElasticTensor` 模块进行处理：
1.  **收集数据**：对于每种应变模式，收集 4 个数据点（应变 $\delta$ vs 应力 $\sigma$）。
2.  **线性回归**：进行最小二乘法拟合，斜率即为对应的弹性刚度分量。
3.  **对称性处理**：利用晶体对称性求平均，输出最终的独立弹性常数。

**预期输出示例**（数值仅供参考）：
```text
Elastic Tensor (GPa):
C11 = 1076.5
C12 = 125.3
C44 = 577.1
...
Bulk Modulus (Voigt) = 442.4 GPa
Shear Modulus (Voigt) = 534.2 GPa
```

### 3.4.3 常见问题排查
如果输出结果显示 `Cij` 全为 0 或数值异常：
1.  **检查 `cal_stress`**：确认 `INPUT` 中是否开启了 `cal_stress 1`？
2.  **检查收敛性**：查看子任务的 `running.log`，确认 SCF 是否收敛？
3.  **检查计算类型**：再次确认是否误用了 `cell-relax`？

---

## 本章总结
通过本章的金刚石案例，我们掌握了 ABACUS 计算弹性常数的标准范式：
1.  **Pre-process**: 使用 `gene_dfm.py` 基于对称性生成形变结构。
2.  **Run**: 配置 `calculation relax` + `cal_stress 1`，固定晶胞优化原子。
3.  **Post-process**: 使用 `compute_dfm.py` 拟合应力-应变关系。

这一流程不仅适用于金刚石，也适用于其他任意晶系（如六方、单斜等）的材料，是通用的计算力学性质的方法。