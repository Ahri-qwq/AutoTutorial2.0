# ABACUS 杂化泛函计算实战：从底层编译到性能调优

## 前言

欢迎来到《ABACUS 杂化泛函计算实战》。在当代计算材料学领域，杂化泛函（Hybrid Functionals）已成为精确描述电子结构、修正带隙预测误差以及处理缺陷能级不可或缺的工具。国产开源密度泛函理论软件 ABACUS 凭借其独特的数值原子轨道（LCAO）基组，结合 LibRI 库的深度优化，为原本昂贵的杂化泛函计算提供了一条兼顾效率与精度的可行路径。

### 学习路线图
本书旨在通过四个阶段，带你从初学者成长为能够驾驭大规模杂化泛函任务的高手：
1.  **环境筑基（第一章）**：攻克编译难关，确保 LibRI、Libxc 与 LibComm 等底层库的正确链接，解决 50% 以上用户会遇到的“环境报错”问题。
2.  **标准实战（第二章）**：通过 HSE06 典型案例，掌握 LCAO 框架下的标准输入参数设置，跑通第一个杂化泛函任务。
3.  **性能进阶（第三章）**：深入理解 $O(N^4)$ 复杂度的计算内核，学习如何通过 MPI 与 OpenMP 的混合并行策略避免内存溢出（OOM），提升计算吞吐量。
4.  **深度定制（第四章）**：掌握自定义泛函参数的技巧，并学习针对难收敛体系的“驯服”方案。

### 知识体系定位
在 ABACUS 的知识图谱中，本教程位于“进阶应用层”。它上承标准 LDA/GGA 计算，下接 Kubo-Greenwood 输运性质研究等高级功能。相较于平面波（PW）基组，本教程重点探讨的 LCAO+LibRI 方案在处理大规模体系杂化泛函计算时具有显著的效率优势。

### 前置知识
在开始本书的学习之前，建议读者已具备以下基础：
- 掌握基础的密度泛函理论（DFT）物理背景。
- 熟悉 Linux 基本命令行操作及 C++/Fortran 软件编译常识。
- 能够独立运行 ABACUS 的标准 LCAO 自洽场计算任务。

---

# 第一章：杂化泛函基础与环境准备

欢迎来到《ABACUS 实战教程》。作为第一章，我们不急于马上运行庞大的计算任务，而是要先夯实物理基础并确保你的“武器”——ABACUS 编译版本——已经为杂化泛函做好了准备。

在我的开发和教学经验中，超过 50% 的用户在初次尝试杂化泛函计算时，遇到的不是收敛问题，而是直接的“未定义符号”或“缺少库”的报错。本章将帮助你理解我们为什么要使用昂贵的杂化泛函，并手把手教你排查和解决环境依赖问题。

---

## 1.1 物理背景与适用场景

### 1.1.1 为什么我们需要杂化泛函？

在标准的密度泛函理论（DFT）中，无论是局域密度近似（LDA）还是广义梯度近似（GGA，如 PBE），都存在一个著名的病态问题：**自相互作用误差（Self-Interaction Error, SIE）**。

简单来说，在经典的 Hartree 势中，电子会错误地与自己的电荷密度发生相互作用。虽然交换关联泛函（XC）试图抵消这一项，但 LDA/GGA 无法完全抵消它。这种残留的排斥力导致电子过度离域化（delocalization）。

**后果是严重的：**
1.  **带隙低估（Bandgap Underestimation）**：这是半导体物理中最痛的点。例如，PBE 计算出的硅（Si）带隙可能只有实验值的一半，甚至将某些窄带隙半导体错误地描述为金属。
2.  **强关联体系失效**：对于过渡金属氧化物（如 NiO, FeO）或 f 电子体系，电子高度局域化，LDA/GGA 往往无法正确描述其磁性基态或绝缘性质。

### 1.1.2 杂化泛函的解决方案

杂化泛函（Hybrid Functionals）的思路非常直接：既然 Hartree-Fock (HF) 理论包含精确的交换能（Exact Exchange, EXX）且完全没有自相互作用误差（但缺少关联能），而 DFT 包含关联能但有 SIE，为什么不把它们混合起来呢？

通用的杂化泛函能量公式可以写为：
$$ E_{xc}^{hybrid} = \alpha E_{x}^{HF} + (1-\alpha)E_{x}^{DFT} + E_{c}^{DFT} $$

其中 $\alpha$ 是混合系数（Mixing parameter）。
-   **PBE0**：$\alpha = 0.25$。即混合了 25% 的 HF 交换能。
-   **HSE06**：这是固体物理中最常用的泛函。为了加速计算，它使用屏蔽库伦势（Screened Coulomb Potential），只在短程引入 HF 交换项，长程使用 DFT。这极大地降低了计算量，同时保留了修正带隙的能力。

### 1.1.3 ABACUS 的独特优势

ABACUS 在处理杂化泛函时具有独特的优势，特别是结合 **数值原子轨道（LCAO）** 基组时。相比于平面波基组，LCAO 基组天然具有局域性，这使得精确交换项（EXX）的计算可以通过 **LibRI**（Resolution of Identity）库进行极其高效的处理。

**适用场景总结**：
*   **必须使用**：计算半导体/绝缘体的准确带隙、能带边位置（Band edge alignment）。
*   **推荐使用**：缺陷形成能、极化子（Polaron）研究、强关联过渡金属氧化物。
*   **慎重使用**：大体系（>500 原子）的动力学模拟（除非你有极其充裕的算力，因为计算量通常是 PBE 的 10-100 倍）。

---

## 1.2 编译依赖与安装检查

这是本章最关键的部分。ABACUS 的杂化泛函功能并非“开箱即用”的默认配置，它依赖于几个特定的外部数学库。

### 1.2.1 核心依赖库：“三驾马车”

要在 ABACUS (LCAO模式) 中高效运行杂化泛函，编译时必须链接以下三个库：

1.  **Libxc**：
    *   **作用**：提供各种交换关联泛函的定义（如 HSE06, PBE0 的具体数学形式）。
    *   **必要性**：如果没有它，ABACUS 根本不知道 `HSE` 是什么。
2.  **LibRI** (Resolution of Identity Library)：
    *   **作用**：这是 ABACUS 杂化泛函计算速度的核心。它专门用于处理 LCAO 基组下的四中心双电子积分（ERI）。
    *   **必要性**：在 LCAO 模式下计算 EXX，必须依赖此库。
3.  **LibComm**：
    *   **作用**：辅助的基础通信库，支持 LibRI 的运行。

### 1.2.2 快速自检：你的 ABACUS 能跑杂化泛函吗？

在开始复杂的计算前，请执行以下简单的“冒烟测试”。

**步骤 1：准备一个最小化的 INPUT 文件**
创建一个名为 `INPUT` 的文件，写入以下内容：
```fortran
INPUT_PARAMETERS
# 基础参数
calculation     scf
basis_type      lcao
ks_solver       genelpa  # 或者 scalapack_gvx

# 关键测试参数
dft_functional  hse      # 指定使用 HSE 杂化泛函
```
*(注：你还需要配套的 `STRU` 和 `KPT` 以及赝势/轨道文件才能运行，这里假设你已有基本的 Si 或 H2O 测试算例)*

**步骤 2：尝试运行**
执行 ABACUS 可执行文件。

**步骤 3：观察报错**

*   **情况 A：运行成功或开始迭代**
    *   🎉 恭喜，你的版本已经支持杂化泛函。

*   **情况 B：报错 "Unrecognized exchange-correlation functional"**
    *   ❌ **原因**：编译时未链接 **Libxc**。
    *   *错误示例*：
        ```text
        Unrecognized exchange-correlation functional 'HSE'.
        ```

*   **情况 C：报错 "compile with libri..."**
    *   ❌ **原因**：编译时未链接 **LibRI**。这是 LCAO 模式下最常见的错误。
    *   *错误示例*：
        ```text
        compile with libri to use hybrid functional in lcao basis
        ```

### 1.2.3 编译修复指南

如果你遇到了上述错误，需要重新编译 ABACUS。请严格按照以下步骤操作：

#### 1. 获取完整的源码（解决 LibRI 缺失的根源）
很多用户直接使用 `git clone` 下载 ABACUS 源码，却忘记了下载子模块。`LibRI` 和 `LibComm` 位于源码的 `deps` 目录下。

**检查方法**：
查看 ABACUS 源码目录下的 `deps/LibRI` 和 `deps/LibComm` 文件夹。如果它们是空的，说明你缺少了源码。

**修复命令**（在 ABACUS 源码根目录下执行）：
```bash
git submodule init
git submodule update --remote --recursive
```
*教授提示：这一步至关重要。如果 `deps` 文件夹为空，后续编译无论怎么设置参数都会失败。*

#### 2. 编译时的 CMake 设置
在编译 ABACUS 时，必须显式开启对这些库的支持。请参考 ABACUS 官方文档的 [Advanced Installation Options](https://abacus.deepmodeling.com/en/latest/advanced/install.html) 章节。

通常，你需要确保 CMake 能够找到 Libxc，并启用 LibRI。一个典型的 CMake 配置逻辑如下（仅供参考，具体路径需根据你的集群环境修改）：

```bash
cmake -B build \
      -DENABLE_LIBXC=ON \
      -DENABLE_LIBRI=ON \
      ... (其他参数)
```

**关键点**：
*   确保 `Libxc` 已经安装在系统中，或者通过 `module load` 加载。
*   `ENABLE_LIBRI=ON` 会告诉编译器去编译 `deps` 目录下的 LibRI 源码并链接。

### 1.2.4 运行时的环境准备
如果你使用的是集群上的模块（Module），运行时不仅需要 ABACUS 的可执行文件，有时还需要加载对应的库环境。

```bash
# 示例：运行时可能需要加载 Libxc
module load libxc/5.1.0  # 版本号视具体情况而定
mpirun -np 4 abacus
```

---

## 本章小结

1.  **物理意义**：杂化泛函通过引入 Hartree-Fock 交换项（EXX），有效修正了 DFT 的自相互作用误差，是计算**带隙**和**局域化电子态**的首选。
2.  **核心依赖**：ABACUS (LCAO) 运行杂化泛函必须依赖 **Libxc**（泛函定义）、**LibRI**（积分加速）和 **LibComm**。
3.  **常见坑**：源码 `deps` 目录为空。务必使用 `git submodule update --remote --recursive` 补全子模块。
4.  **启动开关**：在 INPUT 文件中设置 `dft_functional hse` (或 `pbe0`) 即可开启杂化泛函模式，但这需要编译环境的支持。

做好了这些准备，在下一章中，我们将深入具体的参数设置，教你如何优雅地驾驭 HSE06 计算。

# 第二章：标准计算流程与输入参数

欢迎来到 ABACUS 实战教程的第二章。在上一章中，我们完成了软件的安装与环境配置。本章我们将直接进入“深水区”，构建一个最小可运行的**杂化泛函（Hybrid Functional）**计算案例。

作为一名资深开发者，我深知杂化泛函（如 HSE06）在带隙预测和缺陷能级计算中的重要性，但其高昂的计算成本往往让初学者望而却步。ABACUS 的优势在于其基于数值原子轨道（LCAO）的高效杂化泛函实现。本章将指导你如何通过极其精简的参数设置，正确跑通第一个 HSE 任务。

---

## Section 2.1: 核心输入参数设置

在 ABACUS 中，激活杂化泛函并不复杂，但由于其底层物理实现的特殊性（涉及精确交换项 Exact Exchange, EXX 的计算），我们需要在 `INPUT` 文件中格外注意泛函类型与基组模式的匹配。

### 1. 激活杂化泛函 (`dft_functional`)

这是最关键的一步。不同于常见的 PBE 计算，你需要显式指定杂化泛函的名称。

*   **参数名**: `dft_functional`
*   **推荐值**: `hse` (对应 HSE06) 或 `pbe0`
*   **注意**: 请确保你在编译或安装 ABACUS 时包含了 `Libxc`、`LibRI` 和 `LibComm` 库。如果缺少这些依赖，程序会报错 `Unrecognized exchange-correlation functional` 或提示需编译 LibRI。

### 2. 选择基组模式 (`basis_type`)

虽然 ABACUS 支持平面波（PW）基组，但对于杂化泛函计算，**强烈推荐**使用 LCAO（线性组合原子轨道）基组。

*   **参数名**: `basis_type`
*   **推荐值**: `lcao`
*   **原理**: 杂化泛函计算涉及四中心积分，计算量随基组大小呈 $N^4$ 甚至更高次方的增长。LCAO 基组的定域性和稀疏性可以极大地降低计算成本。相比之下，平面波基组在处理 EXX 项时通常需要极高的截断能，导致计算极其缓慢。

### 3. K 点设置的特殊考量

在 `KPT` 文件中设置 K 点时，需要注意杂化泛函对 K 点密度的敏感性。

*   **物理背景**: 杂化泛函中的库伦势具有长程相互作用（$1/r$），在倒空间中对应 $1/q^2$ 的奇异性。虽然 ABACUS 内部使用了辅助函数处理奇异点，但为了获得收敛的交换能，杂化泛函计算通常需要比普通 GGA 计算**更密集的 K 点网格**。
*   **建议**: 如果你在 PBE 计算中使用了 $4 \times 4 \times 4$ 的网格，在 HSE 计算中可能需要测试 $6 \times 6 \times 6$ 以确保精度。

### 4. 最小可运行 `INPUT` 示例

以下是一个针对硅（Si）晶体的标准 HSE06 计算 `INPUT` 文件模板：

```fortran
INPUT_PARAMETERS
# 1. 一般控制参数
suffix              si_hse_test   # 任务后缀名，用于区分输出文件
calculation         scf           # 计算类型：自洽场计算
symmetry            1             # 开启对称性分析

# 2. 基组与精度控制
basis_type          lcao          # 【关键】使用 LCAO 基组
ecutwfc             60            # 平面波截断能（用于格点积分网格），单位 Ry
scf_thr             1.0e-6        # 自洽收敛阈值
scf_nmax            100           # 最大迭代步数

# 3. 杂化泛函核心设置
dft_functional      hse           # 【关键】激活 HSE06 泛函
```

> **教授的“避坑”指南**：
> 很多初学者会直接复用 PBE 的 `INPUT` 文件，仅修改 `dft_functional`。请务必检查 `basis_type` 是否为 `lcao`。如果你在 `pw` 模式下强行运行 HSE，虽然程序可能不会立即崩溃，但通过 GPU/DCU 加速时通常仅支持 PW 基组的常规 DFT，而 LCAO 才是 CPU 上跑杂化泛函的主力。

---

## Section 2.2: 自动化参数与默认行为

ABACUS 的设计哲学之一是“智能默认”。当你在 `INPUT` 中指定了 `dft_functional` 后，程序会自动配置一系列复杂的底层参数。理解这些默认行为，有助于你在不牺牲精度的前提下“躺平”计算。

### 1. 自动化的 EXX 参数 (`exx_...`)

杂化泛函的通用形式通常包含一部分 Hartree-Fock 交换能（EXX）。以 HSE06 为例，其交换关联泛函中混合了 25% 的短程 HF 交换能。

在 ABACUS 中，当你设置 `dft_functional hse` 时，程序会自动设定以下参数，**通常无需用户手动修改**：

*   **`exx_fock_alpha`**: 自动设为 **0.25**。
    *   *含义*: 混合参数 $\alpha$，代表 HF 交换能的比例。
*   **`exx_erfc_omega`**: 自动设为 **0.11** (单位 $Bohr^{-1}$)。
    *   *含义*: 屏蔽参数 $\omega$，用于控制库伦相互作用的范围（Range-separation）。HSE06 的标准定义即为 $\omega = 0.11$。

**何时需要修改？**
仅当你需要计算带隙与实验值严格匹配的体系（如某些宽禁带半导体），或者进行 PBE0 计算（此时 $\omega=0$）时，才需要手动覆盖这些参数。

### 2. 性能相关的默认行为与调整

杂化泛函计算极其消耗资源。ABACUS 提供了一些高级参数来平衡速度与内存，虽然有默认值，但建议用户根据机器配置进行调整。

#### A. 自洽迭代循环模式 (`exx_separate_loop`)
ABACUS 提供了两种处理 EXX 势更新的策略：

*   **`exx_separate_loop 1` (双层循环)**:
    *   *逻辑*: 外层循环更新 EXX 势，内层循环只更新 GGA 势。
    *   *优势*: **内存消耗较低**。
    *   *劣势*: 总耗时可能略长。
*   **`exx_separate_loop 0` (单层循环)**:
    *   *逻辑*: 每一步同时更新 GGA 和 EXX。
    *   *优势*: **收敛性较好**，适合难收敛体系。
    *   *劣势*: 内存消耗较高（需额外存储历史密度矩阵）。

> **实战建议**: 默认情况或内存受限时，保持默认或手动设为 `1`。如果发现 SCF 震荡不收敛，尝试改为 `0`。

#### B. 实数/复数优化 (`exx_real_number`)
*   **参数名**: `exx_real_number`
*   **默认行为**: 程序通常默认处理复数情况以保证通用性。
*   **优化技巧**: 如果你确定体系具有时间反演对称性且 K 点包含 $\Gamma$ 点等情况，使得密度矩阵 $D(R)$ 的虚部始终为零（绝大多数绝缘体基态计算），可以显式设置：
    ```fortran
    exx_real_number 1
    ```
    这将强制 EXX 在实数域计算，**速度通常可提升 2 倍以上**（例如单步 EXX 耗时从 270s 降至 106s）。

### 3. 截断半径与基组大小（隐性影响）

虽然这不是 `INPUT` 里的参数，但必须在此提及。EXX 计算量与原子轨道截断半径（$R_{cut}$）的 9 次方成正比（$R_{cut}^9$），与基组数量的 4 次方成正比（$N^4$）。

*   **默认行为**: ABACUS 官网提供的标准轨道文件（如 `Si_gga_7au_100Ry_2s2p1d.orb`）通常经过优化。
*   **切记**: 跑杂化泛函时，**千万不要盲目追求大基组**（如 TZDP 或 $R_{cut}=10$ a.u.），除非你确实需要极高的精度且有无限的计算时间。使用默认的 DZP 轨道和适中的截断半径（如 6-7 a.u.）是性价比最高的选择。

---

### 本章小结：你的第一个 HSE 任务清单

在提交任务前，请最后检查一遍：
1.  **INPUT**: `dft_functional hse` + `basis_type lcao`。
2.  **STRU**: 确保使用了推荐的 DZP 轨道文件。
3.  **KPT**: 适当增加了 K 点密度。
4.  **资源**: 尽量使用 OpenMP 多线程并行（如 `OMP_NUM_THREADS=N`），减少 MPI 进程数，以应对 EXX 的内存压力。

在下一章中，我们将深入探讨如何分析计算结果，并利用辅助工具处理能带结构。

# 第三章：性能优化与并行策略（核心）

在计算材料学中，杂化泛函（Hybrid Functionals，如 HSE06, PBE0）因其能更准确地描述带隙和电子局域化行为而被广泛使用。然而，天下没有免费的午餐——杂化泛函引入的精确交换相互作用（Exact Exchange, EXX）项，使得计算复杂度从标准 DFT 的 $O(N^3)$ 飙升至 $O(N^4)$ 甚至更高。

对于 ABACUS 用户而言，如果不进行针对性的优化，一个中等体系的杂化泛函计算可能会轻易耗尽节点内存（OOM）或运行数周无法收敛。本章将揭示 ABACUS 内核中针对 EXX 的并行逻辑，并提供一套经过实战检验的参数配置策略。

---

## 3.1 混合并行策略与内存管理

在 LCAO 基组下计算 EXX 项时，内存带宽和容量通常是最大的瓶颈。ABACUS 采用 **MPI（多进程）** 与 **OpenMP（多线程）** 混合并行的模式。理解二者的区别是优化的第一步：

*   **MPI 进程**：每个进程拥有独立的内存空间。增加 MPI 进程数会显著增加总内存消耗，因为每个进程都需要复制一份基础数据（如基组信息、格点数据等）。
*   **OpenMP 线程**：线程间共享内存。增加线程数几乎不增加内存消耗，主要用于加速计算密集型的循环（如四中心积分）。

### 3.1.1 “多线程、少进程”的黄金法则

针对杂化泛函计算，**内存通常比 CPU 算力更早成为瓶颈**。因此，我们的黄金法则是：**在节点内尽可能开满 OpenMP 线程，尽量减少 MPI 进程数。**

#### 极端内存受限场景（推荐默认方案）
如果你的体系较大（例如 > 200 原子），或者内存紧张，建议**每个计算节点只开启 1 个 MPI 进程**，将节点内的所有物理核心分配给 OpenMP。

**案例**：假设使用 3 个计算节点，每个节点有 56 个物理核心。
*   **Shell 提交脚本设置**：
    ```bash
    # 设置 OpenMP 线程数为 56
    export OMP_NUM_THREADS=56
    
    # 启动 MPI，总共 3 个进程，每个节点 1 个进程
    # -np 3: 总进程数
    # -ppn 1: 每个节点的进程数 (processes per node)
    mpirun -np 3 -ppn 1 abacus
    ```
    *注：具体 MPI 启动参数（如 `-ppn`, `--map-by ppr:1:node`）取决于你的集群调度系统（Slurm/PBS）和 MPI 版本（IntelMPI/OpenMPI）。*

#### 内存充裕时的性能压榨
虽然“1 节点 1 进程”最省内存，但某些计算步骤（如哈密顿量对角化、格点积分）在 MPI 并行下效率更高。如果**确认内存足够**（例如体系较小，或拥有大内存节点），可以适当增加 MPI 进程数以提升整体速度。

**案例**：同上硬件，但体系较小（如 64 原子的 Si），追求极致速度。
*   **配置策略**：尝试每节点 4 进程，每进程 14 线程（4 * 14 = 56 核）。
    ```bash
    export OMP_NUM_THREADS=14
    mpirun -np 12 -ppn 4 abacus
    ```
    *警告：一旦发生 `std::bad_alloc` 或被系统 Kill，请立即回退到“1 节点 1 进程”方案。*

---

## 3.2 自洽迭代循环算法的选择

杂化泛函的自洽场（SCF）收敛往往比普通 GGA 更困难。ABACUS 提供了参数 `exx_separate_loop` 来控制 EXX 的更新策略，这直接决定了内存占用和收敛行为。

### 3.2.1 两种循环模式对比

在 `INPUT` 文件中设置：

#### 模式 0：单层循环 (`exx_separate_loop 0`)
*   **逻辑**：在每一次 SCF 迭代中，同时更新 GGA 势场和 EXX 势场。
*   **优点**：收敛性质较好，适用于电子结构复杂、难以收敛的体系。
*   **缺点**：**内存消耗巨大**。为了通过 `mixing_ndim` 进行历史信息的混合（Charge Mixing），程序需要存储多步的密度矩阵或势场信息，这对 EXX 计算来说是沉重的负担。
*   **适用场景**：小体系、磁性体系、绝缘体-金属相变体系。

#### 模式 1：双层循环 (`exx_separate_loop 1`)
*   **逻辑**：
    *   **外层循环（Blue Loop）**：更新构建 EXX 势场。
    *   **内层循环（Red Loop）**：固定 EXX 势场，只更新 GGA 部分，直到电荷密度变化 `DRHO` 小于 `scf_thr`。
*   **优点**：**极度节省内存**。不需要存储用于混合的历史 EXX 矩阵。
*   **缺点**：总迭代步数可能增加。虽然单步 EXX 计算次数减少，但内层 GGA 循环次数会显著增多。
*   **适用场景**：**大体系（推荐默认）**、内存受限环境、宽带隙绝缘体。

### 3.2.2 决策树：我该选哪种？

```mermaid
graph TD
    A[开始 EXX 计算] --> B{内存是否紧张?}
    B -- 是 --> C[exx_separate_loop 1 (双层循环)]
    B -- 否 --> D{体系是否难以收敛?}
    D -- 是 (如磁性/金属) --> E[exx_separate_loop 0 (单层循环)]
    D -- 否 (如标准半导体) --> C
```

**实战数据参考**（1024 原子 Si 晶体）：
*   **双层循环**：峰值内存 105 GB，总耗时 2591s。
*   **单层循环**：峰值内存 116 GB，总耗时 2062s。
*   *结论*：在内存不溢出的前提下，单层循环可能更快；但为了稳定性，双层循环是处理大体系的安全牌。

---

## 3.3 基组选择的性能陷阱

在 LCAO 方法中，EXX 计算量的物理标度极其陡峭。很多初学者习惯于“无脑”增加精度，这在杂化泛函计算中是致命的。

### 3.3.1 截断半径的幂律灾难 ($R_{cut}^9$)
EXX 的计算量与原子轨道截断半径 $R_{cut}$ 呈约 **9 次方** 的关系。
$$ Cost \propto (R_{cut})^9 $$

*   **陷阱**：在 `STRU` 文件中随意将 $R_{cut}$ 从 7.0 改为 10.0。
*   **后果**：计算时间可能暴增 3-5 倍。
    *   *实测*：Rcut=7au (106s) vs Rcut=10au (282s)。
*   **建议**：**严格使用 ABACUS 官方提供的默认轨道文件**。官方轨道经过了仔细的优化，在精度和 $R_{cut}$ 之间取得了平衡。除非由于重元素或极高压环境导致基组完备性严重不足，否则不要手动增大 $R_{cut}$。

### 3.3.2 基组数目的四次方关系 ($N^4$)
EXX 计算量与基组函数总数 $N$ 呈 4 次方关系。

*   **对比**：
    *   **DZP (Double Zeta + Polarization)**：通常足够精确，性价比最高。
    *   **TZDP (Triple Zeta + Polarization)**：精度略有提升，但计算量剧增。
    *   *实测*：DZP (106s) vs TZDP (612s)。
*   **建议**：对于杂化泛函，**坚持使用 DZP 基组**。如果需要验证精度，可仅在单点能计算时尝试 TZDP，结构优化务必使用 DZP。

---

## 3.4 数值加速技巧

除了并行和算法选择，ABACUS 还提供了一些利用物理特性进行数值加速的参数。

### 3.4.1 实数域计算 (`exx_real_number`)

EXX 计算依赖于实空间的密度矩阵 $D(R)$。
*   **原理**：如果体系具有中心反演对称性，且无自旋轨道耦合（SOC），密度矩阵的虚部理论上为零。
*   **参数设置**：
    ```bash
    # INPUT 文件
    exx_real_number 1  # 强制在实数域计算 EXX
    ```
*   **效果**：将复数运算转为实数运算，计算速度可提升 **2 倍以上**（实测 106s vs 270s）。
*   **适用条件**：
    1.  无自旋轨道耦合（`lspinorb 0`）。
    2.  非螺旋磁性结构。
    3.  绝大多数常规的绝缘体和半导体计算。

### 3.4.2 辅助格点积分精度 (`exx_ccp_rmesh_times`)

ABACUS 使用库伦约束的投影（CCP）或类似的辅助格点技术来处理四中心积分。
*   **参数**：`exx_ccp_rmesh_times`（默认值通常为 1.5 或更高，具体视版本而定）。
*   **含义**：控制辅助积分格点相对于主格点的密度倍数。
*   **调节策略**：
    *   降低该值（例如设为 1.5）：减少辅助格点数，显著加速积分过程，但可能损失微小的精度。
    *   增加该值：提高积分精度，减速。
*   **建议**：保持默认值，仅在极度追求速度且对精度要求不高（如预弛豫阶段）时尝试调低。

---

## 本章总结：EXX 性能优化清单

在提交杂化泛函任务前，请对照以下清单检查：

1.  **并行检查**：是否设置了 `OMP_NUM_THREADS`？是否遵循了“1 节点 1 进程”或“少进程多线程”原则？
2.  **循环策略**：内存是否紧张？如果是，请设置 `exx_separate_loop 1`。
3.  **基组检查**：是否使用了官方推荐的 DZP 轨道？`STRU` 中的 `Rcut` 是否被不必要地改大了？
4.  **物理加速**：如果体系允许（无 SOC），是否开启了 `exx_real_number 1`？

遵循以上策略，你将在 ABACUS 中获得兼具速度与精度的杂化泛函计算体验。

# 第四章：进阶配置与自定义泛函

欢迎来到《ABACUS 实战教程》的进阶篇章。作为一名资深开发者，我深知在实际科研中，标准的 HSE06 或 PBE0 往往只是起步。面对强关联体系、宽禁带半导体或复杂的异质结，我们经常需要“魔改”泛函参数。同时，杂化泛函计算的高昂成本和收敛困难也是困扰无数研究生的噩梦。

本章将带你深入 ABACUS 的内核配置，掌握自定义杂化泛函的“手术刀”，并学会如何驯服那些难以收敛的计算任务。

---

## 4.1 自定义杂化参数：打造你的专属泛函

在 ABACUS 中，虽然我们可以通过 `dft_functional` 关键词直接调用 `hse` 或 `pbe0`，但这些预设值并不总是万能的。例如，在计算某些宽禁带氧化物时，标准的 25% 混合比例可能低估了带隙。此时，我们需要手动调控 Hartree-Fock (HF) 交换项的混合比例（Alpha）和范围分离参数（Omega）。

### 4.1.1 核心参数详解

ABACUS 的 LCAO 模块基于 LibRI 和 Libxc 库，通过以下参数控制杂化泛函的物理行为：

1.  **`exx_hybrid_alpha` (混合比例)**
    *   **物理意义**：决定了在 DFT 交换关联泛函中掺入多少比例的精确 HF 交换能（Exact Exchange）。
    *   **默认值**：
        *   若 `dft_functional` 为 `hf`，默认为 `1.0`。
        *   若 `dft_functional` 为 `pbe0` 或 `hse`，默认为 `0.25`（即 25%）。
    *   **实战场景**：如果你需要使用 PBE0-10%（即 hybrid mixing 为 0.1），需显式设置此参数。

2.  **`exx_hse_omega` (范围分离参数)**
    *   **物理意义**：HSE 泛函特有的参数，用于控制库伦相互作用的衰减范围（Range-separation parameter, $\omega$）。它将库伦势分为短程（Short-range）和长程（Long-range）部分，HF 交换项仅作用于短程。
    *   **默认值**：`0.11` ($bohr^{-1}$)，对应标准的 HSE06 泛函。
    *   **实战场景**：调整 $\omega$ 可以改变屏蔽长度。$\omega \to 0$ 回退到 PBE0；$\omega \to \infty$ 回退到 PBE。

### 4.1.2 实战案例：自定义 PBE0 和 HSE

假设我们需要计算一个特殊的半导体材料，文献建议将 HF 混合比例提高到 35%，或者微调 HSE 的屏蔽参数。

#### 场景 A：自定义 PBE0 (Mixing = 0.35)

```bash
INPUT_PARAMETERS
# ... 基础参数 ...
basis_type      lcao
dft_functional  pbe0           # 基础泛函模板
exx_hybrid_alpha 0.35          # 覆盖默认的 0.25，设置为 35%
```

#### 场景 B：自定义 HSE (Omega = 0.2, Mixing = 0.3)

```bash
INPUT_PARAMETERS
# ... 基础参数 ...
basis_type      lcao
dft_functional  hse            # 基础泛函模板
exx_hybrid_alpha 0.30          # 设置混合比例为 30%
exx_hse_omega    0.20          # 修改范围分离参数
```

> **教授提示 (Professor's Note)**：
> 在修改 `exx_hse_omega` 时请务必小心。这个参数对带隙的影响非常敏感。除非你有明确的文献支持或拟合需求，否则建议保持默认值 `0.11`。此外，SCAN0 泛函在不同文献中定义不同（有的取 0.1，有的取 0.25），使用时请务必通过 `exx_hybrid_alpha` 明确指定你的物理定义。

---

## 4.2 收敛性问题处理：双层循环与单层循环

杂化泛函计算最令人头疼的问题之一就是 SCF 不收敛。ABACUS 针对 LCAO 基组下的杂化泛函提供了两种独特的自洽迭代策略：**双层循环**和**单层循环**。理解它们的区别是解决收敛问题的关键。

### 4.2.1 双层循环 (Double Loop)
这是 ABACUS 的默认或常用策略（取决于具体版本配置，建议显式指定）。

*   **逻辑**：
    *   **外层循环 (Blue Loop)**：更新构建精确交换势（EXX Potential）。
    *   **内层循环 (Red Loop)**：固定 EXX 势，仅更新 GGA 部分的电荷密度，直到达到 `scf_thr`。
*   **参数设置**：
    ```bash
    exx_separate_loop 1
    ```
*   **优点**：**内存占用较低**。因为内层循环不需要反复计算昂贵的 EXX 积分。
*   **缺点**：对于某些复杂体系，外层循环可能发生震荡，导致总能量无法收敛。

### 4.2.2 单层循环 (Single Loop)

*   **逻辑**：
    *   在每一步 SCF 迭代中，同时更新 GGA 密度和 EXX 势。
*   **参数设置**：
    ```bash
    exx_separate_loop 0
    ```
*   **优点**：**收敛稳定性更好**。适用于那些在双层循环中外层震荡剧烈的“钉子户”体系。
*   **缺点**：**内存消耗大**。需要额外存储历史步数的密度矩阵用于 Mixing，峰值内存可能比双层循环高出 10%~20%。

### 4.2.3 教授推荐的收敛策略 (Best Practice)

面对一个未知的杂化泛函计算任务，建议遵循以下流程：

1.  **起手式**：先用纯 GGA (如 PBE) 跑完弛豫或自洽，得到收敛的电荷密度文件 (`SPIN*_CHG.cube` 或密度矩阵)。
2.  **读入密度**：在杂化泛函计算中设置 `start_charge atomic` (如果从头算) 或 `file` (读取 PBE 结果，推荐)。
3.  **尝试双层循环**：设置 `exx_separate_loop 1`。这是效率优先的选择。
4.  **切换单层循环**：如果发现 SCF 能量在震荡（即 `dEtot` 不下降），果断将 `exx_separate_loop` 改为 `0`。

```bash
INPUT_PARAMETERS
# 针对难收敛体系的推荐配置
dft_functional   hse
exx_separate_loop 0          # 开启单层循环模式以增强稳定性
scf_thr          1e-6        # 杂化泛函通常比 GGA 难收敛，建议初期阈值不要设得过低（如 1e-8）
mixing_type      pulay       # 确保使用 Pulay 混合
mixing_beta      0.4         # 如果震荡依旧，适当降低混合因子
```

---

<!-- APPENDIX_START -->
## 附录：常见问题排查 (Troubleshooting)

在杂化泛函的征途上，报错是家常便饭。以下是 ABACUS 开发组总结的“急救清单”。

### A.1 常见报错解析

| 错误信息 (Error Message) | 原因分析 (Root Cause) | 解决方案 (Solution) |
| :--- | :--- | :--- |
| `Unrecognized exchange-correlation functional 'HSE'` | 编译时未链接 Libxc 库。 | 重新编译 ABACUS，确保 `LIBXC_DIR` 正确指向 Libxc 安装路径。 |
| `compile with libri to use hybrid functional in lcao basis` | 编译时未链接 LibRI 库。 | LCAO 杂化泛函依赖 LibRI。请检查 `make` 或 `cmake` 配置，确保包含了 `-DUSE_LIBRI=ON` (具体视 CMakeList 而定) 并链接了 LibRI。 |
| `segmentation fault` (在 EXX 计算阶段) | 内存溢出 (OOM)。 | 杂化泛函对内存极度饥渴。请参考下文的“性能清单”调整并行策略。 |

### A.2 性能与内存优化清单 (Checklist)

如果你的计算太慢或者节点内存爆红，请按顺序检查以下设置：

1.  **并行策略 (至关重要)**：
    *   **现象**：内存不足。
    *   **对策**：EXX 计算部分对 OpenMP 线程并行更友好，而对 MPI 进程并行内存开销大。
    *   **黄金法则**：**少 MPI，多 OpenMP**。
    *   **示例**：在一个 56 核的节点上，推荐 `mpirun -np 1 -env OMP_NUM_THREADS=56 abacus` (极端省内存) 或 `mpirun -np 4 -env OMP_NUM_THREADS=14 abacus` (平衡速度与内存)。千万不要使用 56 个 MPI 进程！

2.  **实数/复数优化**：
    *   **参数**：`exx_real_number`
    *   **检查**：如果体系具有中心反演对称性且 `gamma_only` 为 1，或者你能确定密度矩阵虚部为零，设置 `exx_real_number 1`。这能将 EXX 计算速度提升约 2-3 倍。

3.  **基组与截断半径**：
    *   **检查**：EXX 计算量与基组数目的四次方 ($N^4$) 成正比，与截断半径的九次方 ($R_{cut}^9$) 成正比。
    *   **对策**：不要盲目使用 `tzdp` 或过大的 `Rcut`。对于大多数杂化泛函计算，`dzp` 和默认的 `Rcut` (如 6-7 a.u.) 已经足够。

4.  **辅助格点加速**：
    *   **参数**：`exx_ccp_rmesh_times`
    *   **技巧**：该参数控制库伦势积分的径向格点密度。默认值（HSE 为 1.5）通常是安全的。如果极慢，可确认是否被误设为了高值（如 5.0）。

通过本章的配置，你应该能够驾驭绝大多数杂化泛函计算任务。下一章，我们将探讨如何利用 ABACUS 进行激发态性质的计算。

---

## 附录：进阶学习指南

### 持续探索（Extended Reading）
完成本书的学习后，如果你希望在高性能计算与高精度模拟领域进一步深造，可以尝试以下方向：
1.  **平面波基组下的杂化泛函**：虽然 LCAO 效率更高，但在对精度要求极高的场景下，可以探索 ABACUS 的平面波杂化泛函功能（基于 EXX 模块），尽管其计算成本更高，但在数学完备性上有其独特优势。
2.  **激发态与输运性质**：结合杂化泛函提供的精确电子结构，进一步学习如何利用 Kubo-Greenwood 方法计算材料的电导率与热导率。
3.  **LibRI 底层算法**：深入研究 Resolution of Identity (RI) 技术在减少四中心积分中的应用原理，这有助于你更深刻地理解参数 `exx_characteristic_length` 的物理意义。

### 通用调试建议（Troubleshooting）
-   **编译报错**：若出现“undefined reference”错误，请务必检查 `deps` 文件夹下的子模块是否完整，建议执行 `git submodule update --init --recursive`。
-   **内存溢出（OOM）**：杂化泛函内存消耗极大。在资源有限时，请务必优先增加 OpenMP 线程数（`OMP_NUM_THREADS`），并相应减少 MPI 进程数。
-   **收敛困难**：对于磁性体系或宽禁带半导体，尝试调整 `mixing_beta` 或使用 `diagonalization` 的不同算法，并从预收敛的 PBE 波函数作为起始点。

### 资源链接
-   **ABACUS 官方文档**：[https://abacus.deepmodeling.com/](https://abacus.deepmodeling.com/)
-   **LibRI 源代码仓库**：[https://github.com/deepmodeling/LibRI](https://github.com/deepmodeling/LibRI)
-   **Bohrium Notebook**：推荐在 Bohrium 云端平台上查找相关的交互式教程进行快速验证。
