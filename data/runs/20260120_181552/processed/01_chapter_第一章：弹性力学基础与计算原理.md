# 第一章：弹性力学基础与计算原理

你好，我是你的 ABACUS 导师。在开始编写输入文件之前，我们必须先“校准”我们的物理直觉。

很多初学者容易陷入一个误区：拿到脚本就运行，算出数字就填表。但在计算材料学中，**弹性常数（Elastic Constants）** 的计算是对软件精度和操作流程要求最为严苛的任务之一。它不仅要求极高的电子结构收敛度，还要求你对“应力”与“应变”在微观模拟中的实现方式有深刻理解。

本章我们将剥离复杂的数学推导，直击 ABACUS 计算弹性常数的核心逻辑。

---

## 1.1 广义胡克定律与 Voigt 标记法

在宏观世界，弹簧被拉长遵循 $F=k\Delta x$。在晶体材料的微观世界，这一关系被推广为**广义胡克定律**。

### 1.1.1 物理图景：从张量到矩阵
当晶体受到微小形变（应变 $\epsilon$）时，晶格内部会产生抵抗这种形变的力（应力 $\sigma$）。在弹性极限内，它们呈线性关系：

$$ \sigma_{ij} = \sum_{k,l} C_{ijkl} \epsilon_{kl} $$

这里的 $C_{ijkl}$ 就是我们要计算的**弹性刚度张量（Stiffness Tensor）**。
- **挑战**：这是一个四阶张量，包含 $3 \times 3 \times 3 \times 3 = 81$ 个分量。直接计算这 81 个数是不切实际的。
- **降维**：由于应力张量和应变张量的对称性（$\sigma_{ij}=\sigma_{ji}$），以及热力学势的存在，我们可以使用 **Voigt 标记法** 将下标简化，把四阶张量压缩为 $6 \times 6$ 的矩阵。

**Voigt 映射规则**：
$$ xx \to 1, \quad yy \to 2, \quad zz \to 3, \quad yz \to 4, \quad xz \to 5, \quad xy \to 6 $$

于是，胡克定律变成了矩阵形式（ABACUS 最终求解的目标）：

$$
\begin{bmatrix}
\sigma_{1} \\ \sigma_{2} \\ \sigma_{3} \\ \sigma_{4} \\ \sigma_{5} \\ \sigma_{6}
\end{bmatrix}
=
\begin{bmatrix}
C_{11} & C_{12} & C_{13} & C_{14} & C_{15} & C_{16} \\
C_{12} & C_{22} & C_{23} & C_{24} & C_{25} & C_{26} \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
C_{16} & C_{26} & C_{36} & C_{46} & C_{56} & C_{66}
\end{bmatrix}
\begin{bmatrix}
\epsilon_{1} \\ \epsilon_{2} \\ \epsilon_{3} \\ \epsilon_{4} \\ \epsilon_{5} \\ \epsilon_{6}
\end{bmatrix}
$$

### 1.1.2 晶体对称性的力量
虽然矩阵有 36 个分量，但大多数晶体具有对称性，这使得独立分量大大减少。
- **三斜晶系 (Triclinic)**：对称性最低，需计算 **21** 个独立分量。
- **立方晶系 (Cubic)**：对称性极高，仅需计算 **3** 个独立分量（$C_{11}, C_{12}, C_{44}$）。

> **教授提示**：ABACUS 结合 Python 脚本（如 `pymatgen` 或 `ASE`）工作时，会自动识别晶体对称性，只施加必要的应变模式。你不需要手动推导这些矩阵，但你必须知道：**对称性越高，需要的计算量越少。**

---

## 1.2 应变-应力法 (Strain-Stress Method) 工作流

在 DFT 计算中，获取弹性常数主要有两种流派：“能量-应变法”和“应力-应变法”。**ABACUS 推荐并主要采用的是“应力-应变法”**。

### 1.2.1 为什么选择“应力-应变法”？
- **能量-应变法**：对晶体施加应变，计算总能量，通过拟合能量曲线的二阶导数（曲率）求 $C_{ij}$。这需要大量的采样点来消除数值噪音。
- **应力-应变法**：利用 **Hellmann-Feynman 定理**，DFT 代码可以直接解析计算出原子受力和晶胞应力张量。我们只需施加应变，读取计算出的应力，通过线性拟合 $\sigma = C \epsilon$ 的斜率即可得到 $C_{ij}$。
    - **优势**：效率更高，对计算点数要求更少，且线性拟合通常比二次拟合更稳健。

### 1.2.2 核心工作流详解

一个标准的 ABACUS 弹性常数计算流程包含以下三个关键步骤：

#### 第一步：极高精度的前置优化 (Pre-relaxation)
这是所有步骤中最关键的一步。在施加任何应变之前，原始晶胞必须处于完美的力学平衡状态。
- **原理**：如果原始结构中存在残余应力（Residual Stress），它会作为系统误差叠加到后续的线性拟合中，导致结果严重偏离。
- **ABACUS 设置**：
    - `calculation`: `cell-relax` (同时优化原子位置和晶胞形状)。
    - 收敛标准：必须比常规计算更严格。建议力收敛标准设为 $10^{-3}$ eV/Å 量级，应力收敛标准设为 0.1 kbar 以下。

#### 第二步：施加应变与构型生成 (Deformation)
这一步通常由辅助脚本（如 `gene_dfm.py`）完成。脚本会根据晶体对称性生成一系列变形后的结构文件（`STRU`）。
- **“24种构型”的由来**：
    为了保证结果的统计学可靠性，通常采用：
    $$ 6 \text{ (独立应变模式)} \times 4 \text{ (应变幅值)} = 24 \text{ 个计算任务} $$
    应变幅值通常取微小量，如 $\pm 0.01$ (1%) 和 $\pm 0.005$ (0.5%)，以确保处于线性弹性区间。

#### 第三步：固定晶胞的原子弛豫 (Internal Relaxation)
**这是新手最容易出错的地方！**
我们将变形后的 `STRU` 文件输入 ABACUS 进行计算。此时，晶格矢量（Lattice Vectors）已经被人为拉伸或剪切，我们需要计算在这个固定形变下，原子重新向平衡位置移动后的应力。

- **Critical Configuration (核心配置)**:
    在 `INPUT` 文件中，必须设置：
    ```bash
    calculation  relax   # 仅优化原子位置，固定晶胞形状
    cal_stress   1       # 开启应力张量计算
    cal_force    1       # 开启原子受力计算
    ```

> **⚠️ 致命错误警示**：
> 绝对**不要**在这一步将 `calculation` 设为 `cell-relax`！
> 如果你设为 `cell-relax`，ABACUS 会认为你施加的应变是不稳定的，会自动把晶胞优化回原来的平衡形状（应变被释放），导致你计算的应力全部归零或无意义。

### 1.2.3 风险提示与锦囊妙计

在实战中，你可能会遇到以下棘手情况，请提前记录：

1.  **剪切不稳定性与 Symmetry 设置**：
    当施加剪切应变（如 $\epsilon_{xy}$）时，晶体的对称性会被破坏。有时 ABACUS 的对称性分析功能可能会因为数值精度问题报错，或者强制施加了错误的对称性约束。
    - **解决方案**：如果在计算剪切变形结构时遇到报错或结果诡异，请在 `INPUT` 中显式添加：
      ```bash
      symmetry  0  # 关闭对称性分析，直接计算
      ```

2.  **单位陷阱**：
    ABACUS 的输出文件中，应力单位通常是 **kbar**。而发表文章时常用的弹性常数单位是 **GPa**。
    - **换算关系**：$1 \text{ kbar} = 0.1 \text{ GPa}$。
    - **注意**：通常配套的 Python 后处理脚本（如 `compute_dfm.py`）会自动处理这个转换，但你必须检查脚本的输出日志确认单位，切勿张冠李戴。

---

**本章总结**：
我们确立了通过计算应力张量反推弹性常数的物理路径。最核心的操作原则是：**先做完美的 `cell-relax`，再做固定的 `relax`**。

下一章，我们将进入实战环节，手把手教你准备输入文件并运行计算。