# 电荷密度混合算法介绍

> 来源: https://mcresearch.github.io/abacus-user-guide/algorithm-mix.html

# __电荷密度混合算法介绍

**作者：孙亮，邮箱：l.sun@pku.edu.cn**

**审核：陈默涵，邮箱：mohanchen@pku.edu.cn**

**最后更新时间：2023/11/09**

# __一、背景

做基于 Kohn-Sham Density Functional Theory（KSDFT）的第一性原理计算的过程就是求解 Kohn-Sham (KS)方程 [−12∇2+Veff(r)]ψσi(r)=εσiψσi(r),Veff(r)=Vext(r)+VH(r)+Vxc(r)[−12∇2+Veff(r)]ψiσ(r)=εiσψiσ(r),Veff(r)=Vext(r)+VH(r)+Vxc(r)

的过程。由于其中

VH(r)=∫ρ(r′)|r−r′|dr′,Vxc(r)=δExc[ρ]δρ(r)VH(r)=∫ρ(r′)|r−r′|dr′,Vxc(r)=δExc[ρ]δρ(r)

均依赖于电荷密度ρ(r)ρ(r)，KS 方程无法直接求解，只能采取迭代的方法，也就是自洽场迭代法（scf, self-consistent field）。其流程可以概括为

⋯→ρi−1→Vi−1eff→ρi→Vieff→ρi+1→⋯⋯→ρi−1→Veffi−1→ρi→Veffi→ρi+1→⋯

上述过程也可以看作一个不动点问题：ρ=f(ρ)ρ=f(ρ)，ff代表从ρi−1ρi−1到ρiρi的映射。

我们常常采用**电荷密度混合（charge mixing）** 方法来提升 scf 迭代过程的稳定性和收敛效率，引入 charge mixing 方法后，scf 流程可概括为

⋯→ρi−1in→Vi−1eff→ρi−1out⟶CMρiin→Vieff→ρiout⟶CMρi+1in→⋯⋯→ρini−1→Veffi−1→ρouti−1⟶CMρini→Veffi→ρouti⟶CMρini+1→⋯

其中CMCM表示 charge mixing 方法，它将前几步的电荷密度以一定的比例混合，得到下一步输入ff映射的电荷密度ρinρin。

下面我们将介绍几种常用的 charge mixing 方法：**plain mixing** , **Pulay mixing** , 以及**Broyden mixing** 方法。这三种算法均已实现在 ABACUS 中。

为了方便，下文中我们统一采用狄拉克符号，比如电荷密度记为|ρ⟩|ρ⟩。

# __二、算法介绍

我们一般定义|Fi⟩=|ρiout⟩−|ρiin⟩|Fi⟩=|ρouti⟩−|ρini⟩为**残差** ，当它的模⟨Fi|Fi⟩=0⟨Fi|Fi⟩=0时，迭代达到收敛。实际计算中，无法真正做到模为零，一般设置一个阈值ΔΔ来判断是否收敛。

值得一提的是，下面的推导中，我们都以电荷密度作为变量，但这些算法都适用于 charge mixing 过程中其它量的混合，比如动能密度等。它们也不仅适用于电荷密度混合，也可用于其它的优化问题。

## __1\. Plain mixing

Plain mixing，也称 simple mixing，其思路是将|ρiin⟩|ρini⟩和|ρiout⟩|ρouti⟩做线性组合，得到下一步的|ρi+1in⟩|ρini+1⟩，为了保证混合前后电子数不变，混合的公式为

|ρi+1in⟩=(1−β)|ρiin⟩+β|ρiout⟩=|ρiin⟩+β(|ρiout⟩−|ρiin⟩)=|ρiin⟩+β|Fi⟩,|ρini+1⟩=(1−β)|ρini⟩+β|ρouti⟩=|ρini⟩+β(|ρouti⟩−|ρini⟩)=|ρini⟩+β|Fi⟩,

**其中** ββ**为 mixing 的步长，可以取 0 到 1 间的实数，** ββ**越小，则迭代越稳定，但收敛所需的步数可能越多。（见第三部分，介绍 ABACUS 里面的相关参数）**

一般而言，plain mixing 收敛较慢，不在实际计算中采用。

## __2\. Pulay mixing

Pulay mixing[1]也叫 direct inversion of the iterative sub-space (DIIS) method，其思路是用前nn步的电荷密度{|ρi−n+1in⟩,⋯,|ρi−1in⟩,|ρiin⟩}{|ρini−n+1⟩,⋯,|ρini−1⟩,|ρini⟩}做线性组合，在此线性空间中找到一个“最佳”的电荷密度|ρiopt⟩|ρopti⟩，使得⟨Fiopt|Fiopt⟩⟨Fopti|Fopti⟩取极小值，再由|ρiopt⟩|ρopti⟩和|Fiopt⟩|Fopti⟩线性组合得到下一步的|ρi+1in⟩|ρini+1⟩。

下面我们首先给出算法流程，然后进行相应的推导。

### __2.1 算法流程

需要存储前nn步迭代的{|ρi−n+1in⟩,⋯,|ρi−1in⟩,|ρiin⟩}{|ρini−n+1⟩,⋯,|ρini−1⟩,|ρini⟩}和{|Fi−n+1⟩,⋯,|Fi−1⟩,|Fi⟩}{|Fi−n+1⟩,⋯,|Fi−1⟩,|Fi⟩}，

  * 计算大小为n×nn×n的矩阵A,Ajk=⟨Fi−n+j|Fi−n+k⟩A,Ajk=⟨Fi−n+j|Fi−n+k⟩；
  * 计算逆矩阵A−1A−1；
  * 计算混合系数αj=∑nkA−1jk∑nl∑nkA−1lkαj=∑knAjk−1∑ln∑knAlk−1；
  * 更新密度|ρi+1in⟩=∑nj=1αj(|ρi−n+jin⟩+β|Fi−n+j⟩)|ρini+1⟩=∑j=1nαj(|ρini−n+j⟩+β|Fi−n+j⟩)，ββ为 mixing 的步长。



### __2.2 算法推导

为了记号方便，我们将参与线性组合的前nn步电荷密度{|ρi−n+1in⟩,⋯,|ρi−1in⟩,|ρiin⟩}{|ρini−n+1⟩,⋯,|ρini−1⟩,|ρini⟩}重新标记为{|ρ1in⟩,⋯,|ρn−1in⟩,|ρnin⟩}{|ρin1⟩,⋯,|ρinn−1⟩,|ρinn⟩}。

首先我们定义|ρiopt⟩=∑nj=1αj|ρjin⟩|ρopti⟩=∑j=1nαj|ρinj⟩，为了保证电子数守恒，要求∑nj=1αj=1∑j=1nαj=1。

为了找到最佳的{αj}{αj}组合，使得⟨Fiopt|Fiopt⟩⟨Fopti|Fopti⟩取极小值，同时满足∑nj=1αj=1∑j=1nαj=1的条件，我们采用拉格朗日乘子法，定义

L=⟨Fiopt|Fiopt⟩−λ(∑j=1nαj−1).L=⟨Fopti|Fopti⟩−λ(∑j=1nαj−1).

进一步假设Fiopt[ρiopt]=Fiopt[∑nj=1αjρiin]=∑nj=1αjFj[ρjin]Fopti[ρopti]=Fopti[∑j=1nαjρini]=∑j=1nαjFj[ρinj]，即|Fiopt⟩=∑nj=1αj|Fj⟩|Fopti⟩=∑j=1nαj|Fj⟩，上式变为

L=∑j=1n∑k=1nαj⟨Fj|Fk⟩αk−λ(∑j=1nαj−1)=∑j=1n∑k=1nαjAjkαk−λ(∑j=1nαj−1).L=∑j=1n∑k=1nαj⟨Fj|Fk⟩αk−λ(∑j=1nαj−1)=∑j=1n∑k=1nαjAjkαk−λ(∑j=1nαj−1).

上面我们定义了Ajk=⟨Fj|Fk⟩Ajk=⟨Fj|Fk⟩，它满足Ajk=AkjAjk=Akj。

于是有

∂L∂αj=2∑k=1nAjkαk−λ=0⟶2∑k=1nAjkαk=λ,∂L∂αj=2∑k=1nAjkαk−λ=0⟶2∑k=1nAjkαk=λ,

两边同乘A−1ljAlj−1并对jj求和，有

2∑j=1n∑k=1nA−1ljAjkαk=λ∑j=1nA−1lj⟶2∑k=1nδlkαk=2αl=λ∑j=1nA−1lj.2∑j=1n∑k=1nAlj−1Ajkαk=λ∑j=1nAlj−1⟶2∑k=1nδlkαk=2αl=λ∑j=1nAlj−1.

由∑nl=1αl=1∑l=1nαl=1，有12λ∑nl=1∑nj=1A−1lj=112λ∑l=1n∑j=1nAlj−1=1，因此λ=2∑nl∑njA−1lj.λ=2∑ln∑jnAlj−1.

代回上式，我们得到最佳混合比例

αl=∑njA−1lj∑nk∑njA−1kj.αl=∑jnAlj−1∑kn∑jnAkj−1.

最终，我们得到由前nn步电荷密度线性组合可以得到的“最佳”电荷密度|ρiopt⟩=∑nj=1αj|ρjin⟩|ρopti⟩=∑j=1nαj|ρinj⟩，相应的残差|Fiopt⟩=∑nj=1αj|Fj⟩|Fopti⟩=∑j=1nαj|Fj⟩，其中的系数αj=∑nkA−1jk∑nl∑nkA−1lk.αj=∑knAjk−1∑ln∑knAlk−1.

因此下一次迭代的初始电荷密度

|ρi+1in⟩=|ρiopt⟩+β|Fiopt⟩=∑j=1nαj|ρjin⟩+β∑j=1nαj|Fj⟩=∑j=1nαj(|ρjin⟩+β|Fj⟩).|ρini+1⟩=|ρopti⟩+β|Fopti⟩=∑j=1nαj|ρinj⟩+β∑j=1nαj|Fj⟩=∑j=1nαj(|ρinj⟩+β|Fj⟩).

## __3\. Broyden mixing

Broyden mixing 是拟牛顿法的一种，它的思路是对|F⟩|F⟩的雅可比矩阵的逆进行近似，从而采用牛顿法进行迭代。

在其发展过程中，曾出现过不同的形式，这里我们介绍的是 1988 年 Johnson 提出的 Simplified modified Broyden method[2]，它兼具收敛速度快与内存消耗少的优势，也是 ABACUS 默认采用的 mixing 方法。

我们先给出算法流程，再进行推导，以下推导参考了文献[3]。

### __3.1 算法流程

首先我们定义|Δρiin⟩=|ρiin⟩−|ρi−1in⟩|Δρini⟩=|ρini⟩−|ρini−1⟩，|ΔFi⟩=|Fi⟩−|Fi−1⟩|ΔFi⟩=|Fi⟩−|Fi−1⟩。

需要存储前nn步迭代的{|Δρi−n+1in⟩,|Δρi−n+2in⟩,⋯,|Δρiin⟩}{|Δρini−n+1⟩,|Δρini−n+2⟩,⋯,|Δρini⟩}和{|ΔFi−n+1⟩,|ΔFi−n+2⟩,⋯,|ΔFi⟩}{|ΔFi−n+1⟩,|ΔFi−n+2⟩,⋯,|ΔFi⟩}，

  * 计算大小为n×nn×n的矩阵B,Bjk=⟨ΔFi−n+j|ΔFi−n+k⟩B,Bjk=⟨ΔFi−n+j|ΔFi−n+k⟩；
  * 计算逆矩阵B−1B−1；
  * 计算混合系数αj=−∑nk=1B−1jk⟨ΔFi−n+k|Fi⟩αj=−∑k=1nBjk−1⟨ΔFi−n+k|Fi⟩；
  * 更新密度|ρi+1in⟩=|ρiin⟩+β|Fi⟩+∑nj=1αj(|Δρi−n+jin⟩+β|ΔFi−n+j⟩)|ρini+1⟩=|ρini⟩+β|Fi⟩+∑j=1nαj(|Δρini−n+j⟩+β|ΔFi−n+j⟩)，ββ为 mixing 的步长。



### __3.2 算法推导

#### __3.2.1 牛顿法

我们首先介绍牛顿法，对于 charge mixing 中的不动点问题ρ=f(ρ)ρ=f(ρ)，可以改写为

|F⟩=|ρout⟩−|ρin⟩=0|F⟩=|ρout⟩−|ρin⟩=0，这里|ρout⟩=f(|ρin⟩)|ρout⟩=f(|ρin⟩)。

假设|F′⟩=F[ρ′]=0|F′⟩=F[ρ′]=0，且|F⟩|F⟩在|ρ′⟩|ρ′⟩附近足够光滑，选|ρ′⟩|ρ′⟩附近的|ρ0⟩|ρ0⟩作为出发点，做泰勒展开，有

|F′⟩=|F0⟩+J0(|ρ′⟩−|ρ0⟩)+⋯=0,|F′⟩=|F0⟩+J0(|ρ′⟩−|ρ0⟩)+⋯=0,

其中J0=∂F∂ρ|ρ=ρ0J0=∂F∂ρ|ρ=ρ0为雅可比矩阵，做线性近似后，有

|ρ′⟩=|ρ0⟩−J−10|F0⟩,|ρ′⟩=|ρ0⟩−J0−1|F0⟩,

由此得到牛顿法的迭代公式

|ρi+1in⟩=|ρiin⟩−J−1i|Fi⟩,|ρini+1⟩=|ρini⟩−Ji−1|Fi⟩,

此公式中出现了雅可比矩阵的逆，精确求解将极为耗时，因此一般通过求解线性方程组来得到它：

记Ci=J−1iCi=Ji−1，由|Fi−1⟩=|Fi⟩+Ji(|ρi−1in⟩−|ρiin⟩)|Fi−1⟩=|Fi⟩+Ji(|ρini−1⟩−|ρini⟩)，有Ci|ΔFi⟩=|Δρiin⟩Ci|ΔFi⟩=|Δρini⟩。

综上，牛顿法的完整迭代公式为

|ρi+1in⟩=|ρiin⟩−Ci|Fi⟩,Ci|ΔFi⟩=|Δρiin⟩.|ρini+1⟩=|ρini⟩−Ci|Fi⟩,Ci|ΔFi⟩=|Δρini⟩.

牛顿法中，需要先求出矩阵CiCi，在 charge mixing 的应用场景中，CiCi的大小为N×NN×N，NN为实空间格点数，因此CiCi的求解和储存都很不方便。

#### __3.2.2 Broyden 算法

为了克服牛顿法的问题，人们提出了拟牛顿法（quasi-Newton），其基本思路是对CiCi进行近似，而不是精确求解。拟牛顿法中，我们一般要求近似的CiCi仍然满足Ci|ΔFi⟩=|Δρiin⟩Ci|ΔFi⟩=|Δρini⟩的条件，称为**拟牛顿条件** 。

Simplified modified Broyden method 是拟牛顿法的一种，假设Ci−1Ci−1已知，它通过求解以下优化问题得到CiCi：

minC12∥C−Ci−1∥2F,s.t. Si=CYi.minC12‖C−Ci−1‖F2,s.t. Si=CYi.

其中Si=(|Δρi−n+1in⟩,|Δρi−n+2in⟩,⋯,|Δρiin⟩)Si=(|Δρini−n+1⟩,|Δρini−n+2⟩,⋯,|Δρini⟩)，Yi=(|ΔFi−n+1⟩,|ΔFi−n+2⟩,⋯,|ΔFi⟩)Yi=(|ΔFi−n+1⟩,|ΔFi−n+2⟩,⋯,|ΔFi⟩)，均为大小为N×nN×n的矩阵，Si=CYiSi=CYi要求CC对于前nn步的|Δρjin⟩|Δρinj⟩和|ΔFj⟩|ΔFj⟩均满足拟牛顿条件，

我们仍然采用拉格朗日乘子法，定义

L=12∥C−C′∥2F+12uT(S−CY)T(S−CY)u,L=12‖C−C′‖F2+12uT(S−CY)T(S−CY)u,

为了方便，这里我们省去了Si,YiSi,Yi的下标ii，并且记C′=Ci−1C′=Ci−1，其中u=(u1,u2,⋯,un)Tu=(u1,u2,⋯,un)T为拉格朗日乘子组成的大小为n×1n×1的向量。

将上式展开，有

L=12∑j=1n∑k=1n(Cjk−C′jk)2+12∑j=1n∑k=1nuj[(STS)jk−2∑p=1N∑q=1NSpjCpqYqk+∑p=1N∑q=1N∑l=1NYpjCqpCqlYlk]uk,L=12∑j=1n∑k=1n(Cjk−Cjk′)2+12∑j=1n∑k=1nuj[(STS)jk−2∑p=1N∑q=1NSpjCpqYqk+∑p=1N∑q=1N∑l=1NYpjCqpCqlYlk]uk,

令∂L/∂Cμν=0∂L/∂Cμν=0，由上式有

∂L∂Cμν=Cμν−C′μν−∑j=1n∑k=1n(Sμj−∑l=1NCμlYlj)ujukYνk=0,∂L∂Cμν=Cμν−Cμν′−∑j=1n∑k=1n(Sμj−∑l=1NCμlYlj)ujukYνk=0,

因此

Cμν≈C′μν+∑j=1n∑k=1n(Sμj−∑l=1NC′μlYlj)ujukYνk,Cμν≈Cμν′+∑j=1n∑k=1n(Sμj−∑l=1NCμl′Ylj)ujukYνk,

注意我们将括号中的CμlCμl近似成了C′μlCμl′，上式写成矩阵形式为

C=C′+(S−C′Y)uuTYT,C=C′+(S−C′Y)uuTYT,

代入拟牛顿条件S=CYS=CY中，要求uuT=(YTY)−1uuT=(YTY)−1，因此上述优化问题给出

Ci=Ci−1+(Si−Ci−1Yi)(YTiYi)−1YTi,Ci=Ci−1+(Si−Ci−1Yi)(YiTYi)−1YiT,

假设Ci−1=C0=−βICi−1=C0=−βI，上式变为

Ci=−βI+(Si+βYi)(YTiYi)−1YTi,Ci=−βI+(Si+βYi)(YiTYi)−1YiT,

于是迭代公式为

|ρi+1in⟩=|ρiin⟩−Ci|Fi⟩=|ρiin⟩−(−βI+(Si+βYi)(YTiYi)−1YTi)|Fi⟩=|ρiin⟩+β|Fi⟩−(Si+βYi)(YTiYi)−1YTi|Fi⟩.|ρini+1⟩=|ρini⟩−Ci|Fi⟩=|ρini⟩−(−βI+(Si+βYi)(YiTYi)−1YiT)|Fi⟩=|ρini⟩+β|Fi⟩−(Si+βYi)(YiTYi)−1YiT|Fi⟩.

下面我们将此公式改写成更加清楚的形式，首先令B=YTiYiB=YiTYi，则Bjk=⟨ΔFi−n+j|ΔFi−n+k⟩Bjk=⟨ΔFi−n+j|ΔFi−n+k⟩，因此

−(YTiYi)−1YTi|Fi⟩=−B−1(⟨ΔFi−n+1|Fi⟩,⟨ΔFi−n+2|Fi⟩,⋯,⟨ΔFi|Fi⟩)T=(α1,α2,⋯,αn)T,−(YiTYi)−1YiT|Fi⟩=−B−1(⟨ΔFi−n+1|Fi⟩,⟨ΔFi−n+2|Fi⟩,⋯,⟨ΔFi|Fi⟩)T=(α1,α2,⋯,αn)T,

其中αj=−∑nk=1B−1jk⟨ΔFi−n+j|Fi⟩αj=−∑k=1nBjk−1⟨ΔFi−n+j|Fi⟩。

最终

|ρi+1in⟩=|ρiin⟩+β|Fi⟩−(Si+βYi)(YTiYi)−1YTi|Fi⟩=|ρiin⟩+β|Fi⟩+(Si+βYi)(α1,α2,⋯,αn)T=|ρiin⟩+β|Fi⟩+∑j=1nαj(|Δρi−n+jin⟩+β|ΔFi−n+j⟩).|ρini+1⟩=|ρini⟩+β|Fi⟩−(Si+βYi)(YiTYi)−1YiT|Fi⟩=|ρini⟩+β|Fi⟩+(Si+βYi)(α1,α2,⋯,αn)T=|ρini⟩+β|Fi⟩+∑j=1nαj(|Δρini−n+j⟩+β|ΔFi−n+j⟩).

# __三、ABACUS 相关参数介绍

上述三种算法均已在 ABACUS 中实现，下面我们简要介绍 ABACUS 中 charge mixing 的相关参数，并将它们与上面的公式对应起来，详细文档见[链接](<https://abacus.deepmodeling.com/en/stable/advanced/input_files/input-main.html>)。

  * `mixing_type`：选择 mixing 算法，可选项为 `plain`, `pulay`, `broyden`，分别对应上述三种算法，一般而言，Broyden 算法收敛最快，Pulay 略慢，plain 最慢。默认选项为 `broyden`。
  * `mixing_beta`：对应上述公式中的参数ββ，ββ绝对值越小，则收敛过程越稳定，但达到收敛所需的步数可能增多。对于难以收敛的体系，特别是收敛过程中能量出现上下波动的例子，可以尝试减小 `mixing_beta`。
  * `mixing_ndim`：对应上述公式中的参数nn，Pulay 和 Broyden 算法会借助过去nn步的信息构建下一次迭代的电荷密度，默认值为 8。对于难以收敛的体系，略增大 `mixing_ndim` 可以增强收敛过程的稳定性。
  * `mixing_gg0`：是否采用 Kerker scaling 方法，此方法会在倒空间中给|F⟩|F⟩乘上k2k2+gg02k2k2+gg02的因子，以抑制混合过程中的高频项，其中kk为波矢，gg0gg0由 `mixing_gg0` 设置。特别是对于难以收敛的金属体系，打开 Kerker 方法可以帮助计算达到收敛。
  * `mixing_tau`：是否对动能密度进行混合，适用于使用 meta-GGA 交换关联泛函的场景。
  * `mixing_dftu`：是否对密度矩阵进行混合，适用于使用 DFT+U 的场景。
  * `scf_thr`：对应于 charge mixing 的收敛判据ΔΔ，对于原子轨道基组(LCAO)，默认值为 1e-7，对于平面波基组(PW)，默认值为 1e-9。
  * `scf_thr_type`：选择上述公式中内积⟨f|f⟩⟨f|f⟩的定义，以及相应收敛判据的计算方式。

    * 1：⟨f|g⟩=∬f(r)g(r′)|r−r′|drdr′=4π∫R[f∗(k)g(k)]k2dk⟨f|g⟩=∬f(r)g(r′)|r−r′|drdr′=4π∫R[f∗(k)g(k)]k2dk，RR表示取实部，收敛判据为⟨Δρ|Δρ⟩<Δ⟨Δρ|Δρ⟩<Δ，默认用于 PW 基组；
    * 2：⟨f|f⟩=∫f2(r)dr⟨f|f⟩=∫f2(r)dr，收敛判据为∫|Δρ|dr<Δ∫|Δρ|dr<Δ，默认用于 LCAO 基组。



# __四、参考文献

[1] [Pulay P. Convergence acceleration of iterative sequences. The case of SCF iteration[J]. Chemical Physics Letters, 1980, 73(2): 393-398.](<https://www.sciencedirect.com/science/article/abs/pii/0009261480803964>)

[2] [Johnson D D. Modified Broyden’s method for accelerating convergence in self-consistent calculations[J]. Physical Review B, 1988, 38(18): 12807.](<https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807>)

[3] [Lin L, Yang C. Elliptic preconditioner for accelerating the self-consistent field iteration in Kohn--Sham density functional theory[J]. SIAM Journal on Scientific Computing, 2013, 35(5): S277-S298.](<https://epubs.siam.org/doi/abs/10.1137/120880604>)

Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-07-11 15:17:43 
