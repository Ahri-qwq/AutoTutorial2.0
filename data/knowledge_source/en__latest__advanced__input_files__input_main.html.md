# http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html

> Source: http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html

# Full List of INPUT Keywords[#](#full-list-of-input-keywords)

## System variables[#](#system-variables)

These variables are used to control general system parameters.

### suffix[#](#suffix)

**Type**: String**Description**: In each run, ABACUS will generate a subdirectory in the working directory. This subdirectory contains all the information of the run. The subdirectory name has the format: OUT.suffix, where the`suffix`

is the name you can pick up for your convenience.**Default**: ABACUS

### calculation[#](#calculation)

**Type**: String**Description**: Specify the type of calculation.scf: perform self-consistent electronic structure calculations

`relax_nmax`

parameter depicts the maximal number of ionic iterationscell-relax: perform cell relaxation calculations

md: perform molecular dynamics simulations

`out_pchg`

for more information`out_wfc_norm`

and`out_wfc_re_im`

for more information`SR.csr`

with file format being the same as that generated by[out_mat_hs2](#out-mat-hs2). Note: in the 3.10-LTS version, the command was named`get_S`

`bessel_descriptor_lmax`

,`bessel_descriptor_rcut`

and`bessel_descriptor_tolerence`

. A file named`jle.orb`

will be generated which contains the projectors. An example is provided in examples/H2O-deepks-pwgen_opt_abfs: generate opt-ABFs as discussed in this

[article](https://pubs.acs.org/doi/abs/10.1021/acs.jpclett.0c00481).test_memory: obtain a rough estimation of memory consuption for the calculation

[search_radius](#search-radius)manually

**Default**: scf

### esolver_type[#](#esolver-type)

**Type**: String**Description**: choose the energy solver.ksdft: Kohn-Sham density functional theory

ofdft: orbital-free density functional theory

tdofdft: time-dependent orbital-free density functional theory

tddft: real-time time-dependent density functional theory (RT-TDDFT)

lj: Leonard Jones potential

dp: DeeP potential, see details in

[md.md](../md.html#dpmd)nep: Neuroevolution Potential, see details in

[md.md](../md.html#nep)ks-lr: Kohn-Sham density functional theory + LR-TDDFT (Under Development Feature)

lr: LR-TDDFT with given KS orbitals (Under Development Feature)


**Default**: ksdft

### symmetry[#](#symmetry)

**Type**: Integer**Description**: takes value 1, 0 or -1.**Default**:0:

if

[calculation](#calculation)==md/nscf/get_pchg/get_wf/get_s or[gamma_only](#gamma-only)==True;If (

[dft_fuctional](#dft-functional)==hse/hf/pbe0/scan0 or[rpa](#rpa)==True).If

[efield_flag](#efield-flag)==1

1: else



### symmetry_prec[#](#symmetry-prec)

**Type**: Real**Description**: The accuracy for symmetry analysis. Typically, the default value is good enough, but if the lattice parameters or atom positions in STRU file are not accurate enough, this value should be enlarged., this value can be dynamically changed corresponding to the variation of accuracy of the lattice parameters and atom positions during the relaxation. The new value will be printed in[calculation](#calculation)==cell_relax`OUT.${suffix}/running_cell-relax.log`

in that case.**Default**: 1.0e-6**Unit**: Bohr

### symmetry_autoclose[#](#symmetry-autoclose)

**Type**: Boolean**Availability**:[symmetry](#symmetry)==1**Description**: Control how to deal with error in symmetry analysis due to inaccurate lattice parameters or atom positions in STRU file, especially useful when[calculation](#calculation)==cell-relaxFalse: quit with an error message

True: automatically set symmetry to 0 and continue running without symmetry analysis


**Default**: True

### cal_symm_repr[#](#cal-symm-repr)

**Type**: Integer [Integer](optional)**Description**: Whether to print the matrix representation of symmetry operation to running log file. If the first value is given as 1, then all matrix representations will be printed. The second optional parameter controls the precision (number of digits) to print, default is 3, which is enough for a quick check.**Default**: 1 3

### kpar[#](#kpar)

**Type**: Integer**Description**: Divide all processors into kpar groups, and k points will be distributed among each group. The value taken should be less than or equal to the number of k points as well as the number of MPI processes.**Default**: 1

### bndpar[#](#bndpar)

**Type**: Integer**Description**: Divide all processors into bndpar groups, and bands (only stochastic orbitals now) will be distributed among each group. It should be larger than 0.**Default**: 1

### latname[#](#latname)

**Type**: String**Description**: Specifies the type of Bravias lattice. When set to`none`

, the three lattice vectors are supplied explicitly in STRU file. When set to a certain Bravais lattice type, there is no need to provide lattice vector, but a few lattice parameters might be required. For more information regarding this parameter, consult the[page on STRU file](stru.html).Available options are:

none: free structure

sc: simple cubic

fcc: face-centered cubic

bcc: body-centered cubic

hexagonal: hexagonal

trigonal: trigonal

st: simple tetragonal

bct: body-centered tetragonal

so: orthorhombic

baco: base-centered orthorhombic

fco: face-centered orthorhombic

bco: body-centered orthorhombic

sm: simple monoclinic

bacm: base-centered monoclinic

triclinic: triclinic


**Default**: none

### init_wfc[#](#init-wfc)

**Type**: String**Description**: The type of the starting wave functions.Available options are:

atomic+random: add small random numbers on atomic pseudo-wavefunctions

file: from binary files

`wf*.dat`

, which are output by setting[out_wfc_pw](#out-wfc-pw)to`2`

.random: random numbers

nao+random: add small random numbers on numerical atomic orbitals


`file`

option is useful for the lcao basis set, which is mostly used when[calculation](#calculation)is set to`get_wf`

and`get_pchg`

. See more details in[out_wfc_lcao](#out-wfc-lcao).**Default**: atomic

### init_chg[#](#init-chg)

**Type**: String**Description**: This variable is used for both plane wave set and localized orbitals set. It indicates the type of starting density.atomic: the density is starting from the summation of the atomic density of single atoms.

`charge-density.dat`

first. If it does not exist, the charge density will be read in from cube files. Besides, when you do`nspin=1`

calculation, you only need the density file chgs1.cube. However, if you do`nspin=2`

calculation, you also need the density file chgs2.cube. The density file should be output with these names if you set out_chg = 1 in INPUT file.`wf*.dat`

(see[out_wfc_pw](#out-wfc-pw)) while occupations are read in from file`eig.txt`

.`dmrs1_nao.csr`

in directory[read_file_dir](#read-file-dir).`hrs1_nao.csr`

in directory[read_file_dir](#read-file-dir), and DMR and charge density will be calculated from it.

**Default**: atomic

### init_vel[#](#init-vel)

**Type**: Boolean**Description**:**Default**: False

### mem_saver[#](#mem-saver)

**Type**: Boolean**Availability**: Used only for nscf calculations with plane wave basis set.**Description**: Save memory when performing nscf calculations.0: no memory saving techniques are used.

1: a memory saving technique will be used for many k point calculations.


**Default**: 0

### diago_proc[#](#diago-proc)

**Type**: Integer**Availability**: Used only for plane wave basis set.**Description**:`>0`

: it specifies the number of processes used for carrying out diagonalization. Must be less than or equal to total number of MPI processes. Also, when cg diagonalization is used, diago_proc must be the same as the total number of MPI processes.

**Default**: 0

### nbspline[#](#nbspline)

**Type**: Integer**Description**: If set to a natural number, a Cardinal B-spline interpolation will be used to calculate Structure Factor.`nbspline`

represents the order of B-spline basis and a larger one can get more accurate results but cost more. It is turned off by default.**Default**: -1

### kspacing[#](#kspacing)

**Type**: Real**Description**: Set the smallest allowed spacing between k points, unit in 1/bohr. It should be larger than 0.0, and suggest smaller than 0.25. When you have set this value > 0.0, then the KPT file is unnecessary, and the number of K points nk_i = max(1, int(|b_i|/KSPACING_i)+1), where b_i is the reciprocal lattice vector. The default value 0.0 means that ABACUS will read the applied KPT file. If only one value is set (such as`kspacing 0.5`

), then kspacing values of a/b/c direction are all set to it; and one can also set 3 values to set the kspacing value for a/b/c direction separately (such as:`kspacing 0.5 0.6 0.7`

).**Default**: 0.0**Note**: If gamma_only is set to be true, kspacing is invalid.

### min_dist_coef[#](#min-dist-coef)

**Type**: Real**Description**: A factor related to the allowed minimum distance between two atoms. At the beginning, ABACUS will check the structure, and if the distance of two atoms is shorter than min_dist_coef*(standard covalent bond length), we think this structure is unreasonable. If you want to calculate some structures in extreme conditions like high pressure, you should set this parameter as a smaller value or even 0.**Default**: 0.2

### device[#](#device)

**Type**: String**Description**: Specifies the computing device for ABACUS.Available options are:

cpu: for CPUs via Intel, AMD, or Other supported CPU devices

gpu: for GPUs via CUDA or ROCm.


`ks_solver`

must also be set to the algorithms supported. lcao_in_pw currently does not support`gpu`

.**Default**: cpu

### precision[#](#precision)

**Type**: String**Availability**: Used only for plane wave basis set.**Description**: Specifies the precision when performing scf calculation.single: single precision

double: double precision


**Default**: double

### timer_enable_nvtx[#](#timer-enable-nvtx)

**Type**: Boolean**Description**: Controls whether NVTX profiling labels are emitted by the timer. This feature is only effective on CUDA platforms.True: Enable NVTX profiling labels in the timer.

False: Disable NVTX profiling labels in the timer.


**Default**: False

### nb2d[#](#nb2d)

**Type**: Integer**Description**: When using elpa or scalapack to solver the eigenvalue problem, the data should be distributed by the two-dimensional block-cyclic distribution. This paramter specifies the size of the block. It is valid for:[ks_solver](#ks-solver)is genelpa or scalapack_gvx. If nb2d is set to 0, then it will be automatically set in the program according to the size of atomic orbital basis:if size <= 500: nb2d = 1

if 500 < size <= 1000: nb2d = 32

if size > 1000: nb2d = 64;


[ks_solver](#ks-solver)is dav_subspace, and[diag_subspace](#diag-subspace)is 1 or 2. It is the block size for the diagonization of subspace. If it is set to 0, then it will be automatically set in the program according to the number of band:if number of band > 500: nb2d = 32

if number of band < 500: nb2d = 16



**Default**: 0

## Input files[#](#input-files)

These variables are used to control parameters related to input files.

### stru_file[#](#stru-file)

**Type**: String**Description**: The name of the structure file.When

[calculation](#calculation)is set to`md`

and[md_restart](#md-restart)is set to`true`

, this keyword will NOT work.Refer to

[Doc](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/stru.md)

**Default**: STRU

### kpoint_file[#](#kpoint-file)

**Type**: String**Description**: The name of the k-point file that includes the k-point information of Brillouin zone.`gamma_only`

set to true, the`KPT`

file is unnecessary, because a`KPT`

file will be generated automatically.When more than one k-points are required, an explicit

`KPT`

file is mandatory.Refer to

[Doc](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/kpt.md)

**Default**: KPT

### pseudo_dir[#](#pseudo-dir)

**Type**: String**Description**: The direcotyr of pseudopotential files.**Default**: “”

### orbital_dir[#](#orbital-dir)

**Type**: String**Description**: The directory to save numerical atomic orbitals.**Default**: “”

### read_file_dir[#](#read-file-dir)

**Type**: String**Description**: Location of files, such as the electron density (`chgs1.cube`

), required as a starting point.Example: ‘./’ implies the files to be read are located in the working directory.


**Default**: OUT.$suffix

### restart_load[#](#restart-load)

**Type**: Boolean**Availability**: Used only when numerical atomic orbitals are employed as basis set.**Description**: If[restart_save](#restart-save)is set to true and an electronic iteration is finished, calculations can be restarted from the charge density file, which are saved in the former calculation. Please ensure[read_file_dir](#read-file-dir)is correct, and the charge density file exist.or[dft_fuctional](#dft-functional)==hse/hf/pbe0/scan0), the Hexx® files in the same folder for each processor will also be read.[rpa](#rpa)==True**Default**: False

### spillage_outdir[#](#spillage-outdir)

**Type**: String**Availability**: Used only for plane wave basis set.**Description**: The directory to save the spillage files.**Default**: “./”

## Electronic structure[#](#electronic-structure)

These variables are used to control the electronic structure and geometry relaxation calculations.

### basis_type[#](#basis-type)

**Type**: String**Description**: Choose the basis set.pw: Using plane-wave basis set only.

lcao: Using localized atomic orbital sets.


**Default**: pw

### ks_solver[#](#ks-solver)

**Type**: String**Description**: Choose the diagonalization methods for the Hamiltonian matrix expanded in a certain basis set.For plane-wave basis,

cg: The conjugate-gradient (CG) method.

dav: The Davidson algorithm.

`pw_diag_ndim`

can be set to 2 for this method.

For numerical atomic orbitals basis,

lapack: Use LAPACK to diagonalize the Hamiltonian, only used for serial version

genelpa: Use GEN-ELPA to diagonalize the Hamiltonian.

scalapack_gvx: Use Scalapack to diagonalize the Hamiltonian.

cusolver: Use CUSOLVER to diagonalize the Hamiltonian, at least one GPU is needed.

`device`

to GPU, you can launch the ELPA solver with GPU acceleration (provided that you have installed a GPU-supported version of ELPA, which requires you to manually compile and install ELPA, and the ABACUS should be compiled with -DUSE_ELPA=ON and -DUSE_CUDA=ON). The ELPA solver also supports multi-GPU acceleration.

If you set ks_solver=

`genelpa`

for basis_type=`pw`

, the program will stop with an error message:genelpa can not be used with plane wave basis.

Then the user has to correct the input file and restart the calculation.

**Default**:PW basis: cg.

LCAO basis:

genelpa (if compiling option

`USE_ELPA`

has been set)lapack (if compiling option

`ENABLE_MPI`

has not been set)`USE_ELPA`

has not been set and compiling option`ENABLE_MPI`

has been set)cusolver (if compiling option

`USE_CUDA`

has been set)



### nbands[#](#nbands)

**Type**: Integer**Description**: The number of Kohn-Sham orbitals to calculate. It is recommended to setup this value, especially when smearing techniques are utilized, more bands should be included.**Default**:nspin=1: max(1.2*occupied_bands, occupied_bands + 10)

nspin=4: max(1.2*nelec, nelec + 20)



### nelec[#](#nelec)

**Type**: Real**Description**:`>0.0`

: this denotes the total number of electrons in the system. Must be less than 2*nbands.

**Default**: 0.0

### nelec_delta[#](#nelec-delta)

**Type**: Real**Description**: The total number of electrons will be calculated by`nelec`

+`nelec_delta`

.**Default**: 0.0

### nupdown[#](#nupdown)

**Type**: Real**Description**:0.0: no constrain apply to system.

`>0.0`

: The different number of electrons between spin-up and spin-down channels. The range of value must be in [-nelec ~ nelec]. It is one type of constrainted DFT method, two Fermi energies will be calculated.

**Default**: 0.0

### dft_functional[#](#dft-functional)

**Type**: String**Description**: In our package, the XC functional can either be set explicitly using the`dft_functional`

keyword in`INPUT`

file. If`dft_functional`

is not specified, ABACUS will use the xc functional indicated in the pseudopotential file. On the other hand, if dft_functional is specified, it will overwrite the functional from pseudopotentials and performs calculation with whichever functional the user prefers. We further offer two ways of supplying exchange-correlation functional. The first is using ‘short-hand’ names. A complete list of ‘short-hand’ expressions can be found in[the source code](../../_downloads/d54055d49c4276ef7a86279feb37a0f6/xc_functional.cpp). Supported density functionals are:LDA functionals

LDA (equivalent with PZ and SLAPZNOGXNOGC), PWLDA


GGA functionals

meta-GGA functionals

SCAN (require LIBXC)


Hybrid functionals

PBE0, HF


Hybrid meta-GGA functionals

SCAN0 (require LIBXC)



, and it allows for supplying exchange-correlation functionals as combinations of LIBXC keywords for functional components, joined by a plus sign, for example, dft_functional=‘LDA_X_1D_EXPONENTIAL+LDA_C_1D_CSC’. The list of LIBXC keywords can be found on its**compiling with LIBXC**[website](https://libxc.gitlab.io/functionals/). In this way,**we support all the LDA,GGA and mGGA functionals provided by LIBXC**. Some popular functionals and their usage are: RPBE of[Hammer et al.](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.59.7413), set`dft_functional`

to ‘GGA_X_RPBE+GGA_C_PBE’, and[r\(^{2}\)SCAN](https://pubs.acs.org/doi/10.1021/acs.jpclett.0c02405), set`dft_functional`

to ‘MGGA_X_R2SCAN+MGGA_C_R2SCAN’.`hf`

(pure Hartree-Fock),`pbe0`

(PBE0),`hse`

(Note: in order to use HSE functional, LIBXC is required). Note also that HSE has been tested while PBE0 has NOT been fully tested yet, and the maximum CPU cores for running exx in parallel is \(N(N+1)/2\), with N being the number of atoms.**Default**: Used the same as DFT functional as specified in the pseudopotential files.

### xc_temperature[#](#xc-temperature)

**Type**: Real**Description**: Specifies temperature when using temperature-dependent XC functionals (KSDT and so on).**Default**: 0.0**Unit**: Ry

### xc_exch_ext[#](#xc-exch-ext)

**Type**: Integer Real …**Description**: Customized parameterization on the exchange part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to[LibXC](https://libxc.gitlab.io/functionals/). For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC:[gga_x_pbe.c](https://gitlab.com/libxc/libxc/-/blob/7.0.0/src/gga_x_pbe.c).**Default**: 101 0.8040 0.2195149727645171**Note**:`dft_functional`

to corresponding functional to apply the customized parameterization. For example, if you want to use the PBE functional with customized parameters, you should set`dft_functional`

to`GGA_X_PBE+GGA_C_PBE`

and`xc_exch_ext`

to`101 0.8040 0.2195149727645171`

.`HYB_GGA_XC_HSE06`

and LibXC id is 428, you can set either`xc_exch_ext`

or`xc_corr_ext`

to`428 0.25 0.11 0.11`

(which means 25% Hartree-Fock fraction, 0.11 as range-seperation) and leave the other one unset.Presently this feature can only support parameterization on

**one**exchange functional.


### xc_corr_ext[#](#xc-corr-ext)

**Type**: Integer Real …**Description**: Customized parameterization on the correlation part of XC functional. The first value should be the LibXC ID of the original functional, and latter values are external parameters. Default values are those of Perdew-Burke-Ernzerhof (PBE) functional. For more information on LibXC ID of functionals, please refer to[LibXC](https://libxc.gitlab.io/functionals/). For parameters of functionals of interest, please refer to the source code of LibXC, such as PBE functional interface in LibXC:[gga_c_pbe.c](https://gitlab.com/libxc/libxc/-/blob/7.0.0/src/gga_c_pbe.c).**Default**: 130 0.06672455060314922 0.031090690869654895034 1.0**Note**:`dft_functional`

to corresponding functional to apply the customized parameterization. For example, if you want to use the PBE functional with customized parameters, you should set`dft_functional`

to`GGA_X_PBE+GGA_C_PBE`

and`xc_corr_ext`

to`130 0.06672455060314922 0.031090690869654895034 1.0`

.`HYB_GGA_XC_HSE06`

and LibXC id is 428, you can set either`xc_exch_ext`

or`xc_corr_ext`

to`428 0.25 0.11 0.11`

(which means 25% Hartree-Fock fraction, 0.11 as range-seperation) and leave the other one unset.Presently this feature can only support parameterization on

**one**correlation functional.


### pseudo_rcut[#](#pseudo-rcut)

**Type**: Real**Description**: Cut-off of radial integration for pseudopotentials.**Default**: 15**Unit**: Bohr

### pseudo_mesh[#](#pseudo-mesh)

**Type**: Integer**Description**:0: Use a mesh for radial integration of pseudopotentials.

1: Use the mesh that is consistent with quantum espresso


**Default**: 0

### nspin[#](#nspin)

**Type**: Integer**Description**: The number of spin components of wave functions.1: Spin degeneracy

2: Collinear spin polarized.

[noncollinear polarized](../scf/spin.html#noncollinear-spin-polarized-calculations), nspin will be automatically set to 4 without being specified by the user.

**Default**: 1

### smearing_method[#](#smearing-method)

**Type**: String**Description**: It indicates which occupation and smearing method is used in the calculation.fixed: fixed occupations (available for non-coductors only)

gauss or gaussian: Gaussian smearing method.

mp: methfessel-paxton smearing method; recommended for metals.

mp2: 2-nd methfessel-paxton smearing method; recommended for metals.

mv or cold: marzari-vanderbilt smearing method.


**Default**: gauss

### smearing_sigma[#](#smearing-sigma)

**Type**: Real**Description**: Energy range for smearing.**Default**: 0.015**Unit**: Ry

### smearing_sigma_temp[#](#smearing-sigma-temp)

**Type**: Real**Description**: Energy range for smearing,`smearing_sigma`

= 1/2*kB*`smearing_sigma_temp`

.**Default**: 2 *`smearing_sigma`

/ kB.**Unit**: K

### mixing_type[#](#mixing-type)

**Type**: String**Description**: Charge mixing methods.plain: Just simple mixing.

pulay: Standard Pulay method.

[P. Pulay Chemical Physics Letters, (1980)](https://www.sciencedirect.com/science/article/abs/pii/0009261480803964)broyden: Simplified modified Broyden method.

[D.D. Johnson Physical Review B (1988)](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.38.12807)

In general, the convergence of the Broyden method is slightly faster than that of the Pulay method.

**Default**: broyden

### mixing_beta[#](#mixing-beta)

**Type**: Real**Description**: In general, the formula of charge mixing can be written as \(\rho_{new} = \rho_{old} + \beta * \rho_{update}\), where \(\rho_{new}\) represents the new charge density after charge mixing, \(\rho_{old}\) represents the charge density in previous step, \(\rho_{update}\) is obtained through various mixing methods, and \(\beta\) is set by the parameter`mixing_beta`

. A lower value of ‘mixing_beta’ results in less influence of \(\rho_{update}\) on \(\rho_{new}\), making the self-consistent field (SCF) calculation more stable. However, it may require more steps to achieve convergence. We recommend the following options:0.8:

`nspin=1`

0.4:

`nspin=2`

and`nspin=4`

0: keep charge density unchanged, usually used for restarting with

`init_chg=file`

or testing.`0 < mixing_beta < 0.1`

.

`mixing_beta=0.1`

,`mixing_ndim=20`

, and`mixing_gg0=1.0`

usually works well.**Default**: 0.8 for`nspin=1`

, 0.4 for`nspin=2`

and`nspin=4`

.

### mixing_beta_mag[#](#mixing-beta-mag)

**Type**: Real**Description**: Mixing parameter of magnetic density.**Default**:`4*mixing_beta`

, but the maximum value is 1.6.

`mixing_beta_mag`

is not euqal to `mixing_beta`

means that \(\rho_{up}\) and \(\rho_{down}\) mix independently from each other. This setting will fail for one case where the \(\rho_{up}\) and \(\rho_{down}\) of the ground state refers to different Kohn-Sham orbitals. For an atomic system, the \(\rho_{up}\) and \(\rho_{down}\) of the ground state refers to different Kohn-Sham orbitals. We all know Kohn-Sham orbitals are orthogonal to each other. So the mixture of \(\rho_{up}\) and \(\rho_{down}\) should be exactly independent, otherwise SCF cannot find the ground state forever. To sum up, please make sure `mixing_beta_mag`

and `mixing_gg0_mag`

exactly euqal to `mixing_beta`

and `mixing_gg0`

if you calculate an atomic system.

### mixing_ndim[#](#mixing-ndim)

**Type**: Integer**Description**: It indicates the mixing dimensions in Pulay or Broyden. Pulay and Broyden method use the density from previous mixing_ndim steps and do a charge mixing based on this density.**Default**: 8

### mixing_restart[#](#mixing-restart)

**Type**: double**Description**: If the density difference between input and output`drho`

is smaller than`mixing_restart`

, SCF will restart at next step which means SCF will restart by using output charge density from perivos iteration as input charge density directly, and start a new mixing. Notice that`mixing_restart`

will only take effect once in one SCF.**Default**: 0

### mixing_dmr[#](#mixing-dmr)

**Type**: bool**Availability**: Only for`mixing_restart>=0.0`

**Description**: At n-th iteration which is calculated by`drho<mixing_restart`

, SCF will start a mixing for real-space density matrix by using the same coefficiences as the mixing of charge density.**Default**: false

### mixing_gg0[#](#mixing-gg0)

**Type**: Real**Description**: Whether to perfom Kerker scaling for charge density.`mixing_gg0 = 1.0`

is normally a good starting point. Kerker preconditioner will be automatically turned off if`mixing_beta <= 0.1`

.0: No Kerker scaling is performed.


**Default**: 1.0

### mixing_gg0_mag[#](#mixing-gg0-mag)

**Type**: Real**Description**: Whether to perfom Kerker preconditioner of magnetic density. Note: we do not recommand to open Kerker preconditioner of magnetic density unless the system is too hard to converge.**Default**: 0.0

### mixing_gg0_min[#](#mixing-gg0-min)

**Type**: Real**Description**: The minimum kerker coefficient.**Default**: 0.1

### mixing_angle[#](#mixing-angle)

**Type**: Real**Availability**: Only relevant for non-colinear calculations`nspin=4`

.**Description**: Normal broyden mixing can give the converged result for a given magnetic configuration. If one is not interested in the energies of a given magnetic configuration but wants to determine the ground state by relaxing the magnetic moments’ directions, one cannot rely on the standard Broyden mixing algorithm. To enhance the ability to find correct magnetic configuration for non-colinear calculations, ABACUS implements a promising mixing method proposed by J. Phys. Soc. Jpn. 82 (2013) 114706. Here,`mixing_angle`

is the angle mixing parameter. In fact, only`mixing_angle=1.0`

is implemented currently.**<=0**: Normal broyden mixing for \(m_{x}, m_{y}, m_{z}\)**>0**: Angle mixing for the modulus \(|m|\) with`mixing_angle=1.0`


**Default**: -10.0

`mixing_beta_mag >> mixing_beta`

. The setup of `mixing_beta=0.2`

, `mixing_beta_mag=1.0`

usually works well.

### mixing_tau[#](#mixing-tau)

**Type**: Boolean**Availability**: Only relevant for meta-GGA calculations.**Description**: Whether to mix the kinetic energy density.False: The kinetic energy density will not be mixed.


**Default**: False

### mixing_dftu[#](#mixing-dftu)

**Type**: Boolean**Availability**: Only relevant for DFT+U calculations.**Description**: Whether to mix the occupation matrices.False: The occupation matrices will not be mixed.


**Default**: False

### gamma_only[#](#gamma-only)

**Type**: Integer**Availability**: Only used in localized orbitals set**Description**: Whether to use gamma_only algorithm.0: more than one k-point is used and the ABACUS is slower compared to the gamma only algorithm.

1: ABACUS uses gamma only, the algorithm is faster and you don’t need to specify the k-points file.


**Default**: 0

### scf_nmax[#](#scf-nmax)

**Type**: Integer**Description**: This variable indicates the maximal iteration number for electronic iterations.**Default**: 100

### scf_thr[#](#scf-thr)

**Type**: Real**Description**: It’s the density threshold for electronic iteration. It represents the charge density error between two sequential densities from electronic iterations. Usually for local orbitals, usually 1e-6 may be accurate enough.**Default**: 1.0e-9 (plane-wave basis), or 1.0e-7 (localized atomic orbital basis).**Unit**: Ry if`scf_thr_type=1`

,**dimensionless**if`scf_thr_type=2`


### scf_ene_thr[#](#scf-ene-thr)

**Type**: Real**Description**: It’s the energy threshold for electronic iteration. It represents the total energy error between two sequential densities from electronic iterations.**Default**: -1.0. If the user does not set this parameter, it will not take effect.**Unit**: eV

### scf_thr_type[#](#scf-thr-type)

**Type**: Integer**Description**: Choose the calculation method of convergence criterion.**dimensionless**.

**Default**: 1 (plane-wave basis), or 2 (localized atomic orbital basis).

### scf_os_stop[#](#scf-os-stop)

**Type**: bool**Description**: For systems that are difficult to converge, the SCF process may exhibit oscillations in charge density, preventing further progress toward the specified convergence criteria and resulting in continuous oscillation until the maximum number of steps is reached; this greatly wastes computational resources. To address this issue, this function allows ABACUS to terminate the SCF process early upon detecting oscillations, thus reducing subsequent meaningless calculations. The detection of oscillations is based on the slope of the logarithm of historical drho values… To this end, Least Squares Method is used to calculate the slope of the logarithmically taken drho for the previous`scf_os_ndim`

iterations. If the calculated slope is larger than`scf_os_thr`

, stop the SCF.0: The SCF will continue to run regardless of whether there is oscillation or not.

1: If the calculated slope is larger than

`scf_os_thr`

, stop the SCF.

**Default**: false

### scf_os_thr[#](#scf-os-thr)

**Type**: double**Description**: The slope threshold to determine if the SCF is stuck in a charge density oscillation. If the calculated slope is larger than`scf_os_thr`

, stop the SCF.**Default**: -0.01

### scf_os_ndim[#](#scf-os-ndim)

**Type**: int**Description**: To determine the number of old iterations’`drho`

used in slope calculations.**Default**:`mixing_ndim`


### sc_os_ndim[#](#sc-os-ndim)

**Type**: int**Description**: To determine the number of old iterations to judge oscillation, it occured, more accurate lambda with DeltaSpin method would be calculated, only for PW base.**Default**: 5

### chg_extrap[#](#chg-extrap)

**Type**: String**Description**: Methods to do extrapolation of density when ABACUS is doing geometry relaxations or molecular dynamics.atomic: atomic extrapolation.

first-order: first-order extrapolation.

second-order: second-order extrapolation.


**Default**: first-order (geometry relaxations), second-order (molecular dynamics), else atomic

### lspinorb[#](#lspinorb)

**Type**: Boolean**Description**: Whether to consider spin-orbital coupling effect in the calculation.True: Consider spin-orbital coupling effect, and

`nspin`

is also automatically set to 4.False: Do not consider spin-orbital coupling effect.


**Default**: False

### noncolin[#](#noncolin)

**Type**: Boolean**Description**: Whether to allow non-collinear polarization, in which case the coupling between spin up and spin down will be taken into account.True: Allow non-collinear polarization, and

`nspin`

is also automatically set to 4.False: Do not allow non-collinear polarization.


**Default**: False

### soc_lambda[#](#soc-lambda)

**Type**: Real**Availability**: Relevant for soc calculations.**Description**: Sometimes, for some real materials, both scalar-relativistic and full-relativistic can not describe the exact spin-orbit coupling. Artificial modulation may help in such cases.`soc_lambda`

, which has value range [0.0, 1.0] , is used for modulate SOC effect.`soc_lambda 0.0`

refers to scalar-relativistic case and`soc_lambda 1.0`

refers to full-relativistic case.**Default**: 1.0

### dfthalf_type[#](#dfthalf-type)

Type: int

Availability: Relevant for DFT-1/2 calculations.

Description: Choose the type of DFT-1/2 calcutions. Currently, only the PW basis set is supported.

0: Do not consider DFT-1/2 correction.

1: Apply DFT-1/2(shell DFT-1/2) correction.



```
SEP_FILES
ATOM_LABEL is_enable SEP_FILENAME r_in r_out r_power scale.
```

For example,

```
SEP_FILES
Li 0
F 1 F_pbe_50.sep 0.0 2.2 20.0 1.0
```

[SEP files](http://www.eedevice.com/abacus-half.html). The corresponding self-energy potential files should be placed under [pseudo_dir](#pseudo-dir), maintaining the same location as the pseudopotential files. r_in denotes the inner cutoff radius, r_out denotes the outer cutoff radius, and r_power determines the transition at the edge of the cutoff function—larger values result in a sharper transition, but may hinder convergence; a value of 20 is a suitable choice. scale is the self-energy potential scaling factor, with a default value of 1.

Default: 0


## Electronic structure (SDFT)[#](#electronic-structure-sdft)

[smearing_method](#smearing-method) “fd”. Both “scf” and “nscf” [calculation](#calculation) are supported.

### method_sto[#](#method-sto)

**Type**: Integer**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Different methods to do stochastic DFT[nche_sto](#nche-sto). However, when the memory is not enough, only method 1 can be used.other: use 2


**Default**: 2

### nbands_sto[#](#nbands-sto)

**Type**: Integer or string**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: The number of stochastic orbitals[nbands](#nbands), which represents the number of KS orbitals.0: Perform Kohn-Sham DFT.


**Default**: 256

### nche_sto[#](#nche-sto)

**Type**: Integer**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Chebyshev expansion orders for stochastic DFT.**Default**: 100

### emin_sto[#](#emin-sto)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Trial energy to guess the lower bound of eigen energies of the Hamiltonian Operator \(\hat{H}\).**Default**: 0.0**Unit**: Ry

### emax_sto[#](#emax-sto)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Trial energy to guess the upper bound of eigen energies of the Hamiltonian Operator \(\hat{H}\).**Default**: 0.0**Unit**: Ry

### seed_sto[#](#seed-sto)

**Type**: Integer**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: The random seed to generate stochastic orbitals.0: the seed is decided by time(NULL).

<= -1: Stochastic orbitals have the form of \(\pm1\) with equal probability.

-1: the seed is decided by time(NULL).


**Default**: 0

### initsto_ecut[#](#initsto-ecut)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Stochastic wave functions are initialized in a large box generated by “4*`initsto_ecut`

”.`initsto_ecut`

should be larger than[ecutwfc](#ecutwfc). In this method, SDFT results are the same when using different cores. Besides, coefficients of the same G are the same when ecutwfc is rising to initsto_ecut. If it is smaller than[ecutwfc](#ecutwfc), it will be turned off.**Default**: 0.0**Unit**: Ry

### initsto_freq[#](#initsto-freq)

**Type**: Integer**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Frequency (once each initsto_freq steps) to generate new stochastic orbitals when running md.positive integer: Update stochastic orbitals

0: Never change stochastic orbitals.


**Default**: 0

### npart_sto[#](#npart-sto)

**Type**: Integer**Availability**:[method_sto](#method-sto)=`2`

and[out_dos](#out-dos)= 1 or[cal_cond](#cal-cond)=`True`

**Description**: Make memory cost to 1/npart_sto times of the previous one when running the post process of SDFT like DOS or conductivities.**Default**: 1

## Geometry relaxation[#](#geometry-relaxation)

These variables are used to control the geometry relaxation.

### relax_method[#](#relax-method)

**Type**: Vector of string**Description**: The methods to do geometry optimization. the first element:[relax_new](#relax-new).bfgs : using the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm.

lbfgs: using the Limited-memory Broyden–Fletcher–Goldfarb–Shanno (LBFGS) algorithm.

[relax_cg_thr](#relax-cg-thr).sd: using the steepest descent (SD) algorithm.

[calculation](#calculation)to`md`

and[md_type](#md-type)to`fire`

. Also ionic velocities should be set in this case. See[fire](../md.html#fire)for more details.

**Default**: cg 1**Note**:In the 3.10-LTS version, the type of this parameter is std::string. It can be set to “cg”,“bfgs”,“cg_bfgs”,“bfgs_trad”,“lbfgs”,“sd”,“fire”.

### relax_new[#](#relax-new)

**Type**: Boolean**Description**: At around the end of 2022 we made a new implementation of the Conjugate Gradient (CG) method for`relax`

and`cell-relax`

calculations. But the old implementation was also kept.True: use the new implementation of CG method for

`relax`

and`cell-relax`

calculations.False: use the old implementation of CG method for

`relax`

and`cell-relax`

calculations.

**Default**: True

### relax_scale_force[#](#relax-scale-force)

**Type**: Real**Availability**: Only used when`relax_new`

set to`True`

**Description**: The paramether controls the size of the first conjugate gradient step. A smaller value means the first step along a new CG direction is smaller. This might be helpful for large systems, where it is safer to take a smaller initial step to prevent the collapse of the whole configuration.**Default**: 0.5

### relax_nmax[#](#relax-nmax)

**Type**: Integer**Description**: The maximal number of ionic iteration steps. If set to 0, the code performs a quick “dry run”, stopping just after initialization. This is useful to check for input correctness and to have the summary printed.**Default**: 1 for SCF, 50 for relax and cell-relax calcualtions

### relax_cg_thr[#](#relax-cg-thr)

**Type**: Real**Description**: When move-method is set to`cg_bfgs`

, a mixed algorithm of conjugate gradient (CG) method and Broyden–Fletcher–Goldfarb–Shanno (BFGS) method is used. The ions first move according to CG method, then switched to BFGS method when the maximum of force on atoms is reduced below the CG force threshold, which is set by this parameter.**Default**: 0.5**Unit**: eV/Angstrom

### cal_force[#](#cal-force)

**Type**: Boolean**Description**:**True**: Calculate the force at the end of the electronic iteration**False**: No force calculation at the end of the electronic iteration

**Default**: False if`calculation`

is set to`scf`

, True if`calculation`

is set to`cell-relax`

,`relax`

, or`md`

.

### force_thr[#](#force-thr)

**Type**: Real**Description**: Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to[force_thr_ev](#force-thr-ev)except for the unit, you can choose either you like.**Default**: 0.001**Unit**: Ry/Bohr (25.7112 eV/Angstrom)

### force_thr_ev[#](#force-thr-ev)

**Type**: Real**Description**: Threshold of the force convergence. The threshold is compared with the largest force among all of the atoms. The recommended value for using atomic orbitals is 0.04 eV/Angstrom (0.0016 Ry/Bohr). The parameter is equivalent to[force_thr](#force-thr)except for the unit. You may choose either you like.**Default**: 0.0257112**Unit**: eV/Angstrom (0.03889 Ry/Bohr)

### force_zero_out[#](#force-zero-out)

**Type**: Real**Description**: The atomic forces that are smaller than`force_zero_out`

will be treated as zero.**Default**: 0.0**Unit**: eV/Angstrom

### relax_bfgs_w1[#](#relax-bfgs-w1)

**Type**: Real**Description**: Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information.**Default**: 0.01

### relax_bfgs_w2[#](#relax-bfgs-w2)

**Type**: Real**Description**: Controls the Wolfe condition for Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm used in geometry relaxation. You can look into the paper Phys.Chem.Chem.Phys.,2000,2,2177 for more information.**Default**: 0.5

### relax_bfgs_rmax[#](#relax-bfgs-rmax)

**Type**: Real**Description**: For geometry optimization. It stands for the maximal movement of all the atoms. The sum of the movements from all atoms can be increased during the optimization steps. However, it can not be larger than`relax_bfgs_rmax`

.**Unit**: Bohr**Default**: 0.8

### relax_bfgs_rmin[#](#relax-bfgs-rmin)

**Type**: Real**Description**: In old bfgs algorithm, it indicates the minimal movement of all the atoms. When the movement of all the atoms is smaller than relax_bfgs_rmin Bohr, and the force convergence is still not achieved, the calculation will break down. In the current default bfgs algorithm, this parameter is not used.**Default**: 1e-5**Unit**: Bohr

### relax_bfgs_init[#](#relax-bfgs-init)

**Type**: Real**Description**: For geometry optimization. It stands for the sum of initial movements of all of the atoms.**Default**: 0.5**Unit**: Bohr

### cal_stress[#](#cal-stress)

**Type**: Boolean**Description**:**True**: Calculate the stress at the end of the electronic iteration**False**: No calculation of the stress at the end of the electronic iteration

**Default**: True if`calculation`

is`cell-relax`

, False otherwise.

### stress_thr[#](#stress-thr)

**Type**: Real**Description**: The threshold of the stress convergence. The threshold is compared with the largest component of the stress tensor.**Default**: 0.5**Unit**: kbar

### press1, press2, press3[#](#press1-press2-press3)

**Type**: Real**Description**: The external pressures along three axes. Positive input value is taken as compressive stress.**Default**: 0**Unit**: kbar

### fixed_axes[#](#fixed-axes)

**Type**: String**Availability**: Only used when`calculation`

set to`cell-relax`

**Description**: Axes that are fixed during cell relaxation. Possible choices are:None**: default; all of the axes can relax

volume**: relaxation with fixed volume

shape**: fix shape but change volume (i.e. only lattice constant changes)

a: fix a axis during relaxation

b: fix b axis during relaxation

c: fix c axis during relaxation

ab: fix both a and b axes during relaxation

ac: fix both a and c axes during relaxation

bc: fix both b and c axes during relaxation



Note : fixed_axes = “shape” and “volume” are only available for

[relax_new]= True

**Default**: None

### fixed_ibrav[#](#fixed-ibrav)

**Type**: Boolean**Availability**: Must be used along with[relax_new](#relax-new)set to True, and a specific[latname](#latname)must be provided**Description**:True: the lattice type will be preserved during relaxation

False: No restrictions are exerted during relaxation in terms of lattice type



`fixed_ibrav`

with`fixed_axes`

, but please make sure you know what you are doing. For example, if we are doing relaxation of a simple cubic lattice (`latname`

= “sc”), and we use`fixed_ibrav`

along with`fixed_axes`

= “volume”, then the cell is never allowed to move and as a result, the relaxation never converges.

**Default**: False

### fixed_atoms[#](#fixed-atoms)

**Type**: Boolean**Description**:True: The direct coordinates of atoms will be preserved during variable-cell relaxation.

`m`

keyword in`STRU`

file. For the latter option, check the end of this[instruction](stru.html).

**Default**: False

### cell_factor[#](#cell-factor)

**Type**: Real**Description**: Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation.**Default**: 1.2

## Output information[#](#output-information)

These variables are used to control the output of properties.

### out_freq_ion[#](#out-freq-ion)

**Type**: Integer**Description**: Controls the output interval in**ionic steps**. When set to a positive integer \(N\), information such as charge density, local potential, electrostatic potential, Hamiltonian matrix, overlap matrix, density matrix, and Mulliken population analysis is printed every \(N\) ionic steps.**Default**: 0**Note**: In RT-TDDFT calculations, this parameter is inactive; output frequency is instead controlled by—see its description for details.`out_freq_td`


### out_freq_td[#](#out-freq-td)

**Type**: Integer**Description**: Controls the output interval in**completed electronic evolution steps**during RT-TDDFT calculations. When set to a positive integer \(N\), detailed information (see) is printed every \(N\) electron time-evolution steps (i.e., every \(N\)`out_freq_ion`

`STEP OF ELECTRON EVOLVE`

). For example, if you wish to output information once per ionic step, you should set`out_freq_td`

equal to, since one ionic step corresponds to`estep_per_md`

electronic evolution steps.`estep_per_md`

**Default**: 0**Note**: This parameter is**only active in RT-TDDFT mode**(`esolver_type = tddft`

). It has no effect in ground-state calculations.

### out_freq_elec[#](#out-freq-elec)

**Type**: Integer**Description**: Output the charge density (only binary format, controlled by), wavefunction (controlled by`out_chg`

) per`out_wfc_pw`

`out_freq_elec`

electronic iterations. Note that they are always output when converged or reach the maximum iterations.`scf_nmax`

**Default**:`scf_nmax`


### out_chg[#](#out-chg)

**Type**: Integer [Integer](optional)**Description**: The first integer controls whether to output the charge density on real space grids:`OUT.${suffix}`

. The files are named as:nspin = 1:

`chg.cube`

;nspin = 2:

`chgs1.cube`

, and`chgs2.cube`

;`chgs1.cube`

,`chgs2.cube`

,`chgs3.cube`

, and`chgs4.cube`

; Note that by using the Meta-GGA functional, additional files containing the kinetic energy density will be output with the following names:nspin = 1:

`tau.cube`

;nspin = 2:

`taus1.cube`

, and`taus2.cube`

;nspin = 4:

`taus1.cube`

,`taus2.cube`

,`taus3.cube`

, and`taus4.cube`

;

`taus1_ini.cube`

, etc.`{suffix}-CHARGE-DENSITY.restart`

, useful for large systems.

`3`

as default. For purpose restarting from this file and other high-precision involved calculation, recommend to use`10`

.

or[dft_fuctional](#dft-functional)==hse/hf/pbe0/scan0), the Hexx® files will be output in the folder[rpa](#rpa)==True`OUT.${suffix}`

too, which can be read in NSCF calculation.In molecular dynamics simulations, the output frequency is controlled by

[out_freq_ion](#out-freq-ion).**Default**: 0 3**Note**: In the 3.10-LTS version, the file names are SPIN1_CHG.cube and SPIN1_CHG_INI.cube, etc.

### out_pot[#](#out-pot)

**Type**: Integer**Description**:**total local potential**(i.e., local pseudopotential + Hartree potential + XC potential + external electric field (if exists) + dipole correction potential (if exists) + …) on real space grids (in Ry) into files in the folder`OUT.${suffix}`

. The files are named as:nspin = 1:

`pots1.cube`

;nspin = 2:

`pots1.cube`

and`pots2.cube`

;nspin = 4:

`pots1.cube`

,`pots2.cube`

,`pots3.cube`

, and`pots4.cube`


**electrostatic potential**on real space grids into`OUT.${suffix}/pot_es.cube`

. The Python script named`tools/average_pot/aveElecStatPot.py`

can be used to calculate the average electrostatic potential along the z-axis and outputs it into ElecStaticPot_AVE. Please note that the total local potential refers to the local component of the self-consistent potential, excluding the non-local pseudopotential. The distinction between the local potential and the electrostatic potential is as follows: local potential = electrostatic potential + XC potential.**total local potential**of the initial charge density. The files are named as:nspin = 1:

`pots1_ini.cube`

;nspin = 2:

`pots1_ini.cube`

and`pots2_ini.cube`

;nspin = 4:

`pots1_ini.cube`

,`pots2_ini.cube`

,`pots3_ini.cube`

, and`pots4_ini.cube`



In molecular dynamics calculations, the output frequency is controlled by

[out_freq_ion](#out-freq-ion).**Default**: 0**Note**: In the 3.10-LTS version, the file names are SPIN1_POT.cube and SPIN1_POT_INI.cube, etc.

### out_dmk[#](#out-dmk)

**Type**: Boolean [Integer](optional)**Availability**: Numerical atomic orbital basis**Description**: Whether to output the density matrix for each k-point into files in the folder`OUT.${suffix}`

. The files are named as:For gamma only case:

nspin = 1 and 4:

`dm_nao.csr`

;nspin = 2:

`dms1_nao.csr`

and`dms2_nao.csr`

for the two spin channels.

For multi-k points case:

nspin = 1 and 4:

`dmk1_nao.csr`

,`dmk2_nao.csr`

, …;nspin = 2:

`dmk1s1_nao.csr`

… and`dmk1s2_nao.csr`

… for the two spin channels.


**Default**: False**Note**: In the 3.10-LTS version, the parameter is named`out_dm`

and the file names are SPIN1_DM and SPIN2_DM, etc.

### out_dmr[#](#out-dmr)

**Type**: Boolean [Integer](optional)**Availability**: Numerical atomic orbital basis (multi-k points)**Description**: Whether to output the density matrix with Bravias lattice vector R index into files in the folder`OUT.${suffix}`

. The files are named as`dmr{s}{spin index}{g}{geometry index}{_nao} + {".csr"}`

. Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and the sparse matrix format ‘csr’ is mentioned in[out_mat_hs2](#out-mat-hs2). Finally, if[out_app_flag](#out-app-flag)is set to false, the file name contains the optional ‘g’ index for each ionic step that may have different geometries, and if[out_app_flag](#out-app-flag)is set to true, the density matrix with respect to Bravias lattice vector R accumulates during ionic steps:nspin = 1:

`dmrs1_nao.csr`

;nspin = 2:

`dmrs1_nao.csr`

and`dmrs2_nao.csr`

for the two spin channels.

**Default**: False**Note**: In the 3.10-LTS version, the parameter is named`out_dm1`

, and the file names are data-DMR-sparse_SPIN0.csr and data-DMR-sparse_SPIN1.csr, etc.

### out_wfc_pw[#](#out-wfc-pw)

**Type**: Integer**Availability**: Output electronic wave functions in plane wave basis, or transform the real-space electronic wave function into plane wave basis (see get_wf option in[calculation](#calculation)with NAO basis)**Description**: Whether to output the electronic wavefunction coefficients into files and store them in the folder`OUT.${suffix}`

. The files are named as[out_freq_ion](#out-freq-ion)command to control. To print out the electroinc wave functions every few SCF iterations, use the[out_freq_elec](#out-freq-elec)command and the e index will appear in the file name.0: no output

1: (txt format)

non-gamma-only with nspin=1:

`wfk1_pw.txt`

,`wfk2_pw.txt`

, …;non-gamma-only with nspin=2:

`wfk1s1_pw.txt`

,`wfk1s2_pw.txt`

,`wfk2s1_pw.txt`

,`wfk2s2_pw.txt`

, …;non-gamma-only with nspin=4:

`wfk1s4_pw.txt`

,`wfk2s4_pw.txt`

, …;

2: (binary format)

non-gamma-only with nspin=1:

`wfk1_pw.dat`

,`wfk2_pw.dat`

, …;non-gamma-only with nspin=2:

`wfk1s1_pw.dat`

,`wfk1s2_pw.dat`

,`wfk2s1_pw.dat`

,`wfk2s2_pw.dat`

, …;non-gamma-only with nspin=4:

`wfk1s4_pw.dat`

,`wfk2s4_pw.dat`

, …;


**Default**: 0**Note**: In the 3.10-LTS version, the file names are`WAVEFUNC1.dat`

,`WAVEFUNC2.dat`

, etc.

### out_wfc_lcao[#](#out-wfc-lcao)

**Type**: Integer**Availability**: Numerical atomic orbital basis**Description**: Whether to output the electronic wavefunction coefficients into files and store them in the folder`OUT.${suffix}`

. The files are named as`wf{s}{spin index}{k(optional)}{k-point index}{g(optional)}{geometry index1}{_nao} + {".txt"/".dat"}`

. Here, ‘s’ refers to spin, where s1 means spin up channel while s2 means spin down channel, and ‘s12’ refer to spinor wave functions that contains both spin channels with spin-orbital coupling or noncollinear calculations enabled. In addition, if ‘gamma_only’ is set to 0, then the optinoal k-point sampling index appears with the k-point index attached to the electronic wave function file names. Finally, if[out_app_flag](#out-app-flag)is set to false, the file name contains the optional ‘g’ index for each ionic step that may have different geometries, and if[out_app_flag](#out-app-flag)is set to true, the wave functions accumulate during ionic steps. If the out_app_flag is set to false, a new folder named WFC will be created, and the wave function files will be saved into it.0: no output

1: (txt format)

gamma-only:

`wfs1_nao.txt`

or`wfs2_nao.txt`

, …;non-gamma-only:

`wfs1k1_nao.txt`

or`wfs1k2_nao.txt`

, …;

2: (binary format)

gamma-only:

`wfs1_nao.dat`

or`wfs2_nao.dat`

, …;non-gamma-only:

`wfs1k1_nao.dat`

or`wfs1k2_nao.dat`

, …


The corresponding sequence of the orbitals can be seen in

[Basis Set](../pp_orb.html#basis-set).Also controled by

[out_freq_ion](#out-freq-ion)and[out_app_flag](#out-app-flag).**Default**: False**Note**: In the 3.10-LTS version, the file names are WFC_NAO_GAMMA1_ION1.txt and WFC_NAO_K1_ION1.txt, etc.

### out_dos[#](#out-dos)

**Type**: Integer**Description**: Whether to output the density of states (DOS). For more information, refer to the[dos.md](../elec_properties/dos.html).0: no output

1: output the density of states (DOS)

`doss1g{geom}_{basis}.txt`

, where geom is the geometry index when cell changes or ions move while basis is either`pw`

or`nao`

.nspin=2:

`doss1g{geom}_{basis}.txt`

and`doss2g{geom}_{basis}.txt`

for two spin channles.

2: (LCAO) output the density of states (DOS) and the projected density of states (PDOS)

3: output the Fermi surface file (fermi.bxsf) in BXSF format that can be visualized by XCrySDen


**Default**: 0

### out_ldos[#](#out-ldos)

**Type**: Integer**Description**: Whether to output the local density of states (LDOS), optionally output precision can be set by a second parameter, default is 3.0: no output

[stm_bias](#stm-bias)) in cube file format, which can be used to plot scanning tunneling spectroscopys to mimick STM images using the Python script[plot.py](../../_downloads/ba4568395e4c2733e94568dd9a538c6d/plot.py).[ldos_line](#ldos-line)). Parameters used to control DOS output are also valid for LDOS.3: output both two LDOS modes above.


**Default**: 0

### out_band[#](#out-band)

**Type**: Boolean [Integer](optional)**Description**: Whether to output the eigenvalues of the Hamiltonian matrix (in eV) into the running log during electronic iterations and into a file at the end of calculations. The former can be used with the ‘out_freq_elec’ parameter while the latter option allows the output precision to be set via a second parameter, with a default value of 8. The output file names are:nspin = 1 or 4:

`eig.txt`

;nspin = 2:

`eigs1.txt`

and`eigs2.txt`

;For more information, refer to the

[band.md](../elec_properties/band.html)

**Default**: False

### out_proj_band[#](#out-proj-band)

**Type**: Boolean**Description**: Whether to output the projected band structure. For more information, refer to the[band.md](../elec_properties/band.html)**Default**: False

### out_stru[#](#out-stru)

**Type**: Boolean**Description**: Whether to output structure files per ionic step in geometry relaxation calculations into`OUT.${suffix}/STRU_ION${istep}_D`

, where`${istep}`

is the ionic step.**Default**: False

### out_level[#](#out-level)

**Type**: String**Description**: Control the output level of information in`OUT.${suffix}/running_${calculation}.log`

.ie: electronic iteration level, which prints useful information for electronic iterations;

i: geometry relaxation level, which prints some information for geometry relaxations additionally;

m: molecular dynamics level, which does not print some information for simplicity.


**Default**: ie

### out_alllog[#](#out-alllog)

**Type**: Boolean**Description**: Whether to print information into individual logs from all ranks in an MPI run.`OUT.${suffix}/running_${calculation}_${rank+1}.log`

.`OUT.${suffix}/running_${calculation}.log`

.

**Default**: False

### out_mat_hs[#](#out-mat-hs)

**Type**: Boolean [Integer](optional)**Availability**: Numerical atomic orbital basis**Description**: Whether to print the upper triangular part of the Hamiltonian matrices and overlap matrices for each k-point into files in the directory`OUT.${suffix}`

. The second number controls precision. For more information, please refer to[hs_matrix.md](../elec_properties/hs_matrix.html#out-mat-hs). Also controled by[out_freq_ion](#out-freq-ion)and[out_app_flag](#out-app-flag).For gamma only case:

nspin = 1:

`hks1_nao.txt`

for the Hamiltonian matrix and`sks1_nao.txt`

for the overlap matrix;`hks1_nao.txt`

and`hks2_nao.txt`

for the Hamiltonian matrix and`sks1_nao.txt`

for the overlap matrix. Note that the code will not output`sks2_nao.txt`

because it is the same as`sks1_nao.txt`

;nspin = 4:

`hks12_nao.txt`

for the Hamiltonian matrix and`sks12_nao.txt`

for the overlap matrix.

For multi-k points case:

`hks1k1_nao.txt`

for the Hamiltonian matrix at the 1st k-point, and`sks1k1_nao.txt`

for the overlap matrix for the 1st k-point, …;`hks1k1_nao.txt`

and`hks2k1_nao.txt`

for the two spin channels of the Hamiltonian matrix at the 1st k-point, and`sks1k1_nao.txt`

for the overlap matrix for the 1st k-point. Note that the code will not output`sks2k1_nao.txt`

because it is the same as`sks1k1_nao.txt`

, …;`hks12k1_nao.txt`

for the Hamiltonian matrix at the 1st k-point, and`sks12k1_nao.txt`

for the overlap matrix for the 1st k-point, …;


**Default**: False 8**Unit**: Ry**Note**: In the 3.10-LTS version, the file names are data-0-H and data-0-S, etc.

### out_mat_hs2[#](#out-mat-hs2)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Whether to print files containing the Hamiltonian matrix \(H(R)\) and overlap matrix \(S(R)\) into files in the directory`OUT.${suffix}`

. For more information, please refer to[hs_matrix.md](../elec_properties/hs_matrix.html#out-mat-hs2).**Default**: False**Unit**: Ry**Note**: In the 3.10-LTS version, the file names are data-HR-sparse_SPIN0.csr and data-SR-sparse_SPIN0.csr, etc.

### out_mat_tk[#](#out-mat-tk)

**Type**: Boolean [Integer](optional)**Availability**: Numerical atomic orbital basis**Description**: Whether to print the upper triangular part of the kinetic matrices for each k-point into`OUT.${suffix}/tks1ki_nao.txt`

, where i is the index of k points. One may optionally provide a second parameter to specify the precision.**Default**: False [8]**Unit**: Ry**Note**: In the 3.10-LTS version, the file names are data-TR-sparse_SPIN0.csr and data-TR-sparse_SPIN0.csr, etc.

### out_mat_r[#](#out-mat-r)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Whether to print the matrix representation of the position matrix into a file named`rr.csr`

in the directory`OUT.${suffix}`

. If[calculation](#calculation)is set to`get_s`

, the position matrix can be obtained without scf iterations. For more information, please refer to[position_matrix.md](../elec_properties/position_matrix.html#extracting-position-matrices).**Default**: False**Unit**: Bohr**Note**: In the 3.10-LTS version, the file name is data-rR-sparse.csr.

### out_mat_t[#](#out-mat-t)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Generate files containing the kinetic energy matrix \(T(R)\). The format will be the same as the Hamiltonian matrix \(H(R)\) and overlap matrix \(S(R)\) as mentioned in[out_mat_hs2](#out-mat-hs2). The name of the files will be`trs1_nao.csr`

and so on. Also controled by[out_freq_ion](#out-freq-ion)and[out_app_flag](#out-app-flag).**Default**: False**Unit**: Ry**Note**: In the 3.10-LTS version, the file name is data-TR-sparse_SPIN0.csr.

### out_mat_dh[#](#out-mat-dh)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Whether to print files containing the derivatives of the Hamiltonian matrix. The format will be the same as the Hamiltonian matrix \(H(R)\) and overlap matrix \(S(R)\) as mentioned in[out_mat_hs2](#out-mat-hs2). The name of the files will be`dhrxs1_nao.csr`

,`dhrys1_nao.csr`

,`dhrzs1_nao.csr`

and so on. Also controled by[out_freq_ion](#out-freq-ion)and[out_app_flag](#out-app-flag).**Default**: False**Unit**: Ry/Bohr**Note**: In the 3.10-LTS version, the file name is data-dHRx-sparse_SPIN0.csr and so on.

### out_mat_ds[#](#out-mat-ds)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Whether to print files containing the derivatives of the overlap matrix. The format will be the same as the overlap matrix \(dH(R)\) as mentioned in[out_mat_dh](#out-mat-dh). The name of the files will be`dsrxs1.csr`

and so on. Also controled by[out_freq_ion](#out-freq-ion)and[out_app_flag](#out-app-flag). This feature can be used with`calculation get_s`

.**Default**: False**Unit**: Ry/Bohr**Note**: In the 3.10-LTS version, the file name is data-dSRx-sparse_SPIN0.csr and so on.

### out_mat_xc[#](#out-mat-xc)

**Type**: Boolean**Availability**: Numerical atomic orbital (NAO) and NAO-in-PW basis**Description**: Whether to print the upper triangular part of the exchange-correlation matrices in Kohn-Sham orbital representation: \(\braket{\psi_i|V_\text{xc}^\text{(semi-)local}+V_\text{exx}+V_\text{DFTU}|\psi_j}\) for each k point into files in the directory`OUT.${suffix}`

, which is useful for the subsequent GW calculation (the code is still under development). (Note that currently DeePKS term is not included.) The files are named`vxcs1k$i_nao.txt`

, where`$i`

corresponds to the k point index. The band (KS orbital) energy for each (k-point, spin, band) will be printed in the file`OUT.${suffix}/vxc_out.dat`

. If EXX is calculated, the local and EXX part of band energy will also be printed in`OUT.${suffix}/vxc_local_out.dat`

and`OUT.${suffix}/vxc_exx_out.dat`

, respectively. All the`vxc*_out.dat`

files contains 3 integers (nk, nspin, nband) followed by nk*nspin*nband lines of energy Hartree and eV.**Default**: False**Unit**: Ry**Note**: In the 3.10-LTS version, the file name is k-$k-Vxc and so on.

### out_mat_xc2[#](#out-mat-xc2)

**Type**: Boolean**Availability**: Numerical atomic orbital (NAO) basis**Description**: Whether to print the exchange-correlation matrices in numerical orbital representation: \(\braket{\phi_i|V_\text{xc}^\text{(semi-)local}+V_\text{exx}+V_\text{DFTU}|\phi_j}(\mathbf{R})\) in CSR format in the directory`OUT.${suffix}`

. (Note that currently DeePKS term is not included. ) The files are named`Vxc_R_spin$s`

.**Default**: False**Unit**: Ry**Note**: In the 3.10-LTS version, the file name is Vxc_R_spin$s and so on.

### out_mat_l[#](#out-mat-l)

**Type**: Boolean [Integer](optional)**Availability**: Numerical atomic orbital (NAO) basis**Description**: Whether to print the expectation value of the angular momentum operator \(\hat{L}_x\), \(\hat{L}_y\), and \(\hat{L}_z\) in the basis of the localized atomic orbitals. The files are named`OUT.${suffix}/${suffix}_Lx.dat`

,`OUT.${suffix}/${suffix}_Ly.dat`

, and`OUT.${suffix}/${suffix}_Lz.dat`

. The second integer controls the precision of the output.**Default**: False 8

### out_xc_r[#](#out-xc-r)

**Type**: Integer [Integer](optional)**Description**: The first integer controls whether to output the exchange-correlation (in Bohr^-3) on real space grids using Libxc to folder`OUT.${suffix}`

:0: rho, amag, sigma, exc

1: vrho, vsigma

2: v2rho2, v2rhosigma, v2sigma2

3: v3rho3, v3rho2sigma, v3rhosigma2, v3sigma3

[Libxc](https://libxc.gitlab.io/manual/libxc-5.1.x/)

`3`

as default.

**Default**: -1 3

### out_eband_terms[#](#out-eband-terms)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: Whether to print the band energy terms separately in the file`OUT.${suffix}/${term}_out.dat`

. The terms include the kinetic, pseudopotential (local + nonlocal), Hartree and exchange-correlation (including exact exchange if calculated).**Default**: False

### dm_to_rho (Under Development Feature)[#](#dm-to-rho-under-development-feature)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: Reads density matrix \(DM(R)\) in npz format and creates electron density on grids. This feature does not work for gamma-only calculations. Only supports serial calculations.**Default**: False

### out_mul[#](#out-mul)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: Whether to print the Mulliken population analysis result into`OUT.${suffix}/mulliken.txt`

. In molecular dynamics calculations, the output frequency is controlled by[out_freq_ion](#out-freq-ion).**Default**: False

### out_app_flag[#](#out-app-flag)

**Type**: Boolean**Availability**: Numerical atomic orbital basis (not gamma-only algorithm)**Description**: Whether to output \(r(R)\), \(H(R)\), \(S(R)\), \(T(R)\), \(dH(R)\), \(H(k)\), \(S(k)\) and \(wfc(k)\) matrices in an append manner during molecular dynamics calculations. Check input parameters[out_mat_r](#out-mat-r),[out_mat_hs2](#out-mat-hs2),[out_mat_t](#out-mat-t),[out_mat_dh](#out-mat-dh),[out_mat_hs](#out-mat-hs)and[out_wfc_lcao](#out-wfc-lcao)for more information.**Default**: true

### out_ndigits[#](#out-ndigits)

**Type**: Integar**Availability**:`out_mat_hs 1`

case presently.**Description**: Controls the length of decimal part of output data, such as charge density, Hamiltonian matrix, Overlap matrix and so on.**Default**: 8

### out_element_info[#](#out-element-info)

**Type**: Boolean**Description**: Whether to print element information into files in the directory`OUT.${suffix}/${element_label}`

, including pseudopotential and orbital information of the element (in atomic Ryberg units).**Default**: False

### restart_save[#](#restart-save)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: Whether to save charge density files per ionic step, which are used to restart calculations. According to the value of[read_file_dir](#read-file-dir):auto: These files are saved in folder

`OUT.${suffix}/restart/`

;other: These files are saved in folder

`${read_file_dir}/restart/`

.

or[dft_fuctional](#dft-functional)==hse/hf/pbe0/scan0), the Hexx® files for each processor will also be saved in the above folder, which can be read in EXX calculation with[rpa](#rpa)==True.[restart_load](#restart-load)==True**Default**: False

### rpa (Under Development Feature)[#](#rpa-under-development-feature)

**Type**: Boolean**Description**: Generate output files used in rpa calculations.**Note**: Ifis set to 1, additional files containing the necessary information for exploiting symmetry in the subsequent rpa calculation will be output:`symmetry`

`irreducible_sector.txt`

,`symrot_k.txt`

and`symrot_R.txt`

**Default**: False

### out_pchg[#](#out-pchg)

**Type**: String**Availability**: For both PW and LCAO. When`basis_type = lcao`

, used when`calculation = get_pchg`

.**Description**: Specifies the electronic states to calculate the charge densities \(|\psi_{i}(\boldsymbol{r})|^{2}\) with state index \(i\) for, using a space-separated string of 0s and 1s. Each digit in the string corresponds to a state, starting from the first state. A`1`

indicates that the charge density should be calculated for that state, while a`0`

means the state will be ignored. The parameter allows a compact and flexible notation (similar to), for example the syntax`ocp_set`

`1 4*0 5*1 0`

is used to denote the selection of states:`1`

means calculate for the first state,`4*0`

skips the next four states,`5*1`

means calculate for the following five states, and the final`0`

skips the next state. It’s essential that the total count of states does not exceed the total number of states (`nbands`

); otherwise, it results in an error, and the process exits. The input string must contain only numbers and the asterisk (`*`

) for repetition, ensuring correct format and intention of state selection. The outputs comprise multiple`.cube`

files following the naming convention`pchgi[state]s[spin]k[kpoint].cube`

.**Default**: none

### out_wfc_norm[#](#out-wfc-norm)

**Type**: String**Availability**: For both PW and LCAO. When`basis_type = lcao`

, used when`calculation = get_wf`

.**Description**: Specifies the electronic states to calculate the real-space wave function modulus (norm, or known as the envelope function) \(|\psi_i(\boldsymbol{r})|\) with state index \(i\). The syntax and state selection rules are identical to, but the output is the norm of the wave function. The outputs comprise multiple`out_pchg`

`.cube`

files following the naming convention`wfi[state]s[spin]k[kpoint].cube`

.**Default**: none

### out_wfc_re_im[#](#out-wfc-re-im)

**Type**: String**Availability**: For both PW and LCAO. When`basis_type = lcao`

, used when`calculation = get_wf`

.**Description**: Specifies the electronic states to calculate the real and imaginary parts of the wave function \(\text{Re}(\psi_i(\boldsymbol{r}))\) and \(\text{Im}(\psi_i(\boldsymbol{r}))\) with state index \(i\). The syntax and state selection rules are identical to, but the output contains both the real and imaginary components of the wave function. The outputs comprise multiple`out_pchg`

`.cube`

files following the naming convention`wfi[state]s[spin]k[kpoint][re/im].cube`

.**Default**: none

### if_separate_k[#](#if-separate-k)

**Type**: Boolean**Availability**: For both PW and LCAO. When`basis_type = pw`

, used if`out_pchg`

is set. When`basis_type = lcao`

, used only when`calculation = get_pchg`

and`gamma_only = 0`

.**Description**: Specifies whether to write the partial charge densities for all k-points to individual files or merge them.**Warning**: Enabling symmetry may produce unwanted results due to reduced k-point weights and symmetry operations in real space. Therefore when calculating partial charge densities, if you are not sure what you want exactly, it is strongly recommended to set`symmetry = -1`

. It is noteworthy that your`symmetry`

setting should remain the same as that in the SCF procedure.**Default**: false

### out_elf[#](#out-elf)

**Type**: Integer [Integer](optional)**Availability**: Only for Kohn-Sham DFT and Orbital Free DFT.**Description**: Whether to output the electron localization function (ELF) in the folder`OUT.${suffix}`

. The files are named asnspin = 1:

nspin = 2:


`3`

as default. For purpose restarting from this file and other high-precision involved calculation, recommend to use`10`

.

In molecular dynamics calculations, the output frequency is controlled by

[out_freq_ion](#out-freq-ion).**Default**: 0 3

### out_spillage[#](#out-spillage)

**Type**: Integer**Availability**: Only for Kohn-Sham DFT with plane-wave basis.**Description**: This output is only intentively needed by the ABACUS numerical atomic orbital generation workflow. This parameter is used to control whether to output the overlap integrals between truncated spherical Bessel functions (TSBFs) and plane-wave basis expanded wavefunctions (named as`OVERLAP_Q`

), and between TSBFs (named as`OVERLAP_Sq`

), also their first order derivatives. The output files are named starting with`orb_matrix`

. A value of`2`

would enable the output.**Default**: 0

## Density of states[#](#density-of-states)

These variables are used to control the calculation of DOS. [Detailed introduction](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/elec_properties/dos.md)

### dos_edelta_ev[#](#dos-edelta-ev)

**Type**: Real**Description**: The step size in writing Density of States (DOS)**Default**: 0.01**Unit**: eV

### dos_sigma[#](#dos-sigma)

**Type**: Real**Description**: The width of the Gaussian factor when obtaining smeared Density of States (DOS)**Default**: 0.07**Unit**: eV

### dos_scale[#](#dos-scale)

**Type**: Real**Description**: Defines the energy range of DOS output as (emax-emin)*(1+dos_scale), centered at (emax+emin)/2. This parameter will be used when dos_emin and dos_emax are not set.**Default**: 0.01**Unit**: eV

### dos_emin_ev[#](#dos-emin-ev)

**Type**: Real**Description**: The minimal range for Density of States (DOS)If set, “dos_scale” will be ignored.


**Default**: Minimal eigenenergy of \(\hat{H}\)**Unit**: eV

### dos_emax_ev[#](#dos-emax-ev)

**Type**: Real**Description**: The maximal range for Density of States (DOS)If set, “dos_scale” will be ignored.


**Default**: Maximal eigenenergy of \(\hat{H}\)**Unit**: eV

### dos_nche[#](#dos-nche)

**Type**: Integer**Description**: The order of Chebyshev expansions when using Stochastic Density Functional Theory (SDFT) to calculate DOS.**Default**: 100

### stm_bias[#](#stm-bias)

**Type**: Real Real(optional) Integer(optional)**Description**: The bias voltage used to calculate local density of states to simulate scanning tunneling microscope, see details in[out_ldos](#out-ldos). When using three parameters:The first parameter specifies the initial bias voltage value.

The second parameter defines the voltage increment (step size between consecutive bias values).

The third parameter determines the total number of voltage points


**Default**: 1.0**Unit**: V

### ldos_line[#](#ldos-line)

**Type**: Real*6 Integer(optional)**Description**: Specify the path of the three-dimensional space and display LDOS in the form of a two-dimensional color chart, see details in[out_ldos](#out-ldos). The first three paramenters are the direct coordinates of the start point, the next three paramenters are the direct coordinates of the end point, and the final one is the number of points along the path, whose default is 100.**Default**: 0.0 0.0 0.0 0.0 0.0 1.0 100

## NAOs[#](#naos)

`OUT.${suffix}/orb_matrix.${i}.dat`

, which serves as an input file for the generation of NAOs. Please check SIAB package for more information.

### bessel_nao_ecut[#](#bessel-nao-ecut)

**Type**: Real**Description**: “Energy cutoff” (in Ry) of spherical Bessel functions. The number of spherical Bessel functions that constitute the radial parts of NAOs is determined by sqrt(`bessel_nao_ecut`

)\(\times\)`bessel_nao_rcut`

/\(\pi\).**Default**:`ecutwfc`


### bessel_nao_tolerence[#](#bessel-nao-tolerence)

**Type**: Real**Description**: Tolerance when searching for the zeros of spherical Bessel functions.**Default**: 1.0e-12

### bessel_nao_rcut[#](#bessel-nao-rcut)

**Type**: Real**Description**: Cutoff radius (in Bohr) and the common node of spherical Bessel functions used to construct the NAOs.**Default**: 6.0

### bessel_nao_smooth[#](#bessel-nao-smooth)

**Type**: Boolean**Description**: If True, NAOs will be smoothed near the cutoff radius by \(1-\exp\left(-\frac{(r-r_{cut})^2}{2\sigma^2}\right)\). See`bessel_nao_rcut`

for \(r_{cut}\) and`bessel_nao_sigma`

for \(\sigma\).**Default**: True

### bessel_nao_sigma[#](#bessel-nao-sigma)

**Type**: Real**Description**: Smoothing range (in Bohr). See also`bessel_nao_smooth`

.**Default**: 0.1

## DeePKS[#](#deepks)

### deepks_out_labels[#](#deepks-out-labels)

**Type**: Integer**Availability**: Numerical atomic orbital basis**Description**: Print labels and descriptors for DeePKS in OUT.${suffix}. The names of these files start with “deepks”.0 : No output.

1 : Output intermediate files needed during DeePKS training.

`deepks_<property>.npy`

or`deepks_<property>.csr`

, where the units and formats are the same as label files`<property>.npy`

or`<property>.csr`

required for training, except that the first dimension (`nframes`

) is excluded. System structrue files are also given in`deepks_atom.npy`

and`deepks_box.npy`

in the unit of*Bohr*, which means`lattice_constant`

should be set to 1 when training.

**Note**: When`deepks_out_labels`

equals**1**, the path of a numerical descriptor (an`orb`

file) is needed to be specified under the`NUMERICAL_DESCRIPTOR`

tag in the`STRU`

file. For example:NUMERICAL_ORBITAL H_gga_8au_60Ry_2s1p.orb O_gga_7au_60Ry_2s2p1d.orb NUMERICAL_DESCRIPTOR jle.orb

This is not needed when

`deepks_out_labels`

equals 2.**Default**: 0

### deepks_out_freq_elec[#](#deepks-out-freq-elec)

**Type**: Integer**Availability**: Numerical atomic orbital basis**Description**: When`deepks_out_freq_elec`

is greater than 0, print labels and descriptors for DeePKS in OUT.${suffix}/DeePKS_Labels_Elec per`deepks_out_freq_elec`

electronic iterations, with suffix`_e*`

to distinguish different steps. Often used with`deepks_out_labels`

equals 1.**Default**: 0

### deepks_out_base[#](#deepks-out-base)

**Type**: String**Availability**: Numerical atomic orbital basis and`deepks_out_freq_elec`

is greater than 0**Description**: Print labels and descriptors calculated by base functional ( determined by`deepks_out_base`

) and target functional ( determined by`dft_functional`

) for DeePKS in per`deepks_out_freq_elec`

electronic iterations. The SCF process, labels and descriptors output of the target functional are all consistent with those when the target functional is used alone. The only additional output under this configuration is the labels of the base functional. Often used with`deepks_out_labels`

equals 1.**Default**: None

### deepks_scf[#](#deepks-scf)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: perform self-consistent field iteration in DeePKS method**Note**: A trained, traced model file is needed.**Default**: False

### deepks_equiv[#](#deepks-equiv)

**Type**: Boolean**Availability**: Numerical atomic orbital basis**Description**: whether to use equivariant version of DeePKS**Note**: the equivariant version of DeePKS-kit is still under development, so this feature is currently only intended for internal usage.**Default**: False

### deepks_model[#](#deepks-model)

**Type**: String**Availability**: Numerical atomic orbital basis and`deepks_scf`

is true**Description**: the path of the trained, traced neural network model file generated by[deepks-kit](https://github.com/deepmodeling/deepks-kit)**Default**: None

### bessel_descriptor_lmax[#](#bessel-descriptor-lmax)

**Type**: Integer**Availability**:`gen_bessel`

calculation**Description**: the maximum angular momentum of the Bessel functions generated as the projectors in DeePKS**NOte**: To generate such projectors, set calculation type to`gen_bessel`

in ABACUS. See also[calculation](#calculation).**Default**: 2

### bessel_descriptor_ecut[#](#bessel-descriptor-ecut)

**Type**: Real**Availability**:`gen_bessel`

calculation**Description**: energy cutoff of Bessel functions**Default**: same as ecutwfc**Unit**: Ry

### bessel_descriptor_tolerence[#](#bessel-descriptor-tolerence)

**Type**: Real**Availability**:`gen_bessel`

calculation**Description**: tolerance for searching the zeros of Bessel functions**Default**: 1.0e-12

### bessel_descriptor_rcut[#](#bessel-descriptor-rcut)

**Type**: Real**Availability**:`gen_bessel`

calculation**Description**: cutoff radius of Bessel functions**Default**: 6.0**Unit**: Bohr

### bessel_descriptor_smooth[#](#bessel-descriptor-smooth)

**Type**: Boolean**Availability**:`gen_bessel`

calculation**Description**: smooth the Bessel functions at radius cutoff**Default**: False

### bessel_descriptor_sigma[#](#bessel-descriptor-sigma)

**Type**: Real**Availability**:`gen_bessel`

calculation**Description**: smooth parameter at the cutoff radius of projectors**Default**: 0.1**Unit**: Bohr

### deepks_bandgap[#](#deepks-bandgap)

**Type**: Int**Availability**: Numerical atomic orbital basis and`deepks_scf`

is true**Description**: include bandgap label for DeePKS training0: Don’t include bandgap label

1: Include target bandgap label (see

[deepks_band_range](#deepks-band-range)for more details)2: Include multiple bandgap label (see

[deepks_band_range](#deepks-band-range)for more details)

**Default**: 0

### deepks_band_range[#](#deepks-band-range)

**Type**: Int*2**Availability**: Numerical atomic orbital basis,`deepks_scf`

is true, and`deepks_bandgap`

is 1 or 2**Description**: The first value should not be larger than the second one and the meaning differs in different cases below`deepks_bandgap`

is 1: Bandgap label is the energy between`LUMO + deepks_band_range[0]`

and`LUMO + deepks_band_range[1]`

. If not set, it will calculate energy between HOMO and LUMO states.`deepks_bandgap`

is 2: Bandgap labels are energies between HOMO and all states in range [`LUMO + deepks_band_range[0]`

,`LUMO + deepks_band_range[1]`

] (Thus there are`deepks_band_range[1] - deepks_band_range[0] + 1`

bandgaps in total). If HOMO is included in the setting range, it will be ignored since it will always be zero and has no valuable messages (`deepks_band_range[1] - deepks_band_range[0]`

bandgaps in this case).

**Default**: -1 0

### deepks_v_delta[#](#deepks-v-delta)

**Type**: int**Availability**: Numerical atomic orbital basis**Description**: Include V_delta/V_delta_R (Hamiltonian in k/real space) label for DeePKS training. When`deepks_out_labels`

is true and`deepks_v_delta`

> 0 (k space), ABACUS will output`deepks_hbase.npy`

,`deepks_vdelta.npy`

and`deepks_htot.npy`

(htot=hbase+vdelta). When`deepks_out_labels`

is true and`deepks_v_delta`

< 0 (real space), ABACUS will output`deepks_hrtot.csr`

,`deepks_hrdelta.csr`

. Some more files output for different settings.`deepks_v_delta`

= 1:`deepks_vdpre.npy`

, which is used to calculate V_delta during DeePKS training.`deepks_v_delta`

= 2:`deepks_phialpha.npy`

and`deepks_gevdm.npy`

, which can be used to calculate`deepks_vdpre.npy`

. A recommanded method for memory saving.`deepks_v_delta`

= -1:`deepks_vdrpre.npy`

, which is used to calculate V_delta_R during DeePKS training.`deepks_v_delta`

= -2:`deepks_phialpha_r.npy`

and`deepks_gevdm.npy`

, which can be used to calculate`deepks_vdrpre.npy`

. A recommanded method for memory saving.

**Default**: 0

### deepks_out_unittest[#](#deepks-out-unittest)

**Type**: Boolean**Description**: generate files for constructing DeePKS unit test**Note**: Not relevant when running actual calculations. When set to 1, ABACUS needs to be run with only 1 process.**Default**: False

## OFDFT: orbital free density functional theory[#](#ofdft-orbital-free-density-functional-theory)

### of_kinetic[#](#of-kinetic)

**Type**: String**Availability**: OFDFT**Description**: The type of KEDF (kinetic energy density functional).Analytical functionals:

**wt**: Wang-Teter.**tf**: Thomas-Fermi.**vw**: von Weizsäcker.**tf+**: TF \(\rm{\lambda}\) vW, the parameter \(\rm{\lambda}\) can be set by`of_vw_weight`

.**lkt**: Luo-Karasiev-Trickey.**xwm**: Xu-Wang-Ma

Machine learning (ML) based functionals:

**ml**: ML-based KEDF allows for greater flexibility, enabling users to set related ML model parameters themselves. see[ML-KEDF: machine learning based kinetic energy density functional for OFDFT](#ml-kedf-machine-learning-based-kinetic-energy-density-functional-for-ofdft).**mpn**: ML-based Physically-constrained Non-local (MPN) KEDF. ABACUS automatically configures the necessary parameters, requiring no manual intervention from the user.**cpn5**: Multi-Channel MPN (CPN) KEDF with 5 channels. Similar to mpn, ABACUS handles all parameter settings automatically.

**Default**: wt

### of_method[#](#of-method)

**Type**: String**Availability**: OFDFT**Description**: The optimization method used in OFDFT.**cg1**: Polak-Ribiere. Standard CG algorithm.**cg2**: Hager-Zhang (generally faster than cg1).**tn**: Truncated Newton algorithm.

**Default**: tn

### of_conv[#](#of-conv)

**Type**: String**Availability**: OFDFT**Description**: Criterion used to check the convergence of OFDFT.**energy**: Ttotal energy changes less than`of_tole`

.**potential**: The norm of potential is less than`of_tolp`

.**both**: Both energy and potential must satisfy the convergence criterion.

**Default**: energy

### of_tole[#](#of-tole)

**Type**: Real**Availability**: OFDFT**Description**: Tolerance of the energy change for determining the convergence.**Default**: 2e-6**Unit**: Ry

### of_tolp[#](#of-tolp)

**Type**: Real**Availability**: OFDFT**Description**: Tolerance of potential for determining the convergence.**Default**: 1e-5**Unit**: Ry

### of_tf_weight[#](#of-tf-weight)

**Type**: Real**Availability**: OFDFT with`of_kinetic=tf, tf+, wt, xwm`

**Description**: Weight of TF KEDF (kinetic energy density functional).**Default**: 1.0

### of_vw_weight[#](#of-vw-weight)

**Type**: Real**Availability**: OFDFT with`of_kinetic=vw, tf+, wt, lkt, xwm`

**Description**: Weight of vW KEDF (kinetic energy density functional).**Default**: 1.0

### of_wt_alpha[#](#of-wt-alpha)

**Type**: Real**Availability**: OFDFT with`of_kinetic=wt`

**Description**: Parameter alpha of WT KEDF (kinetic energy density functional).**Default**: \(5/6\)

### of_wt_beta[#](#of-wt-beta)

**Type**: Real**Availability**: OFDFT with`of_kinetic=wt`

**Description**: Parameter beta of WT KEDF (kinetic energy density functional).**Default**: \(5/6\)

### of_wt_rho0[#](#of-wt-rho0)

**Type**: Real**Availability**: OFDFT with`of_kinetic=wt`

**Description**: The average density of system.**Default**: 0.0**Unit**: Bohr^-3

### of_hold_rho0[#](#of-hold-rho0)

**Type**: Boolean**Availability**: OFDFT with`of_kinetic=wt`

**Description**: Whether to fix the average density rho0.**True**: rho0 will be fixed even if the volume of system has changed, it will be set to True automatically if`of_wt_rho0`

is not zero.**False**: rho0 will change if volume of system has changed.

**Default**: False

### of_lkt_a[#](#of-lkt-a)

**Type**: Real**Availability**: OFDFT with`of_kinetic=lkt`

**Description**: Parameter a of LKT KEDF (kinetic energy density functional).**Default**: 1.3

### of_xwm_rho_ref[#](#of-xwm-rho-ref)

**Type**: Real**Availability**: OFDFT with`of_kinetic=xwm`

**Description**: Reference charge density for XWM kinetic energy functional. If set to 0, the program will use average charge density.**Default**: 0.0

### of_xwm_kappa[#](#of-xwm-kappa)

**Type**: Real**Availability**: OFDFT with`of_kinetic=xwm`

**Description**: Parameter \(\kappa\) for XWM kinetic energy functional. See PHYSICAL REVIEW B 100, 205132 (2019) for optimal values.**Default**: 0.0

### of_read_kernel[#](#of-read-kernel)

**Type**: Boolean**Availability**: OFDFT with`of_kinetic=wt`

**Description**: Whether to read in the kernel file.**True**: The kernel of WT KEDF (kinetic energy density functional) will be filled from the file specified by`of_kernel_file`

.**False**: The kernel of WT KEDF (kinetic energy density functional) will be filled from formula.

**Default**: False

### of_kernel_file[#](#of-kernel-file)

**Type**: String**Availability**: OFDFT with`of_read_kernel=True`

**Description**: The name of WT kernel file.**Default**: WTkernel.txt

### of_full_pw[#](#of-full-pw)

**Type**: Boolean**Availability**: OFDFT**Description**: Whether to use full planewaves.**True**: Ecut will be ignored while collecting planewaves, so that all planewaves will be used in FFT.**False**: Only use the planewaves inside ecut, the same as KSDFT.

**Default**: True

### of_full_pw_dim[#](#of-full-pw-dim)

**Type**: Integer**Availability**: OFDFT with`of_full_pw = True`

**Description**: Specify the parity of FFT dimensions.**0**: either odd or even.**1**: odd only.**2**: even only.

`of_full_pw_dim = 1`

if`nbspline != -1`

.**Default**: 0

## ML-KEDF: machine learning based kinetic energy density functional for OFDFT[#](#ml-kedf-machine-learning-based-kinetic-energy-density-functional-for-ofdft)

### of_ml_gene_data[#](#of-ml-gene-data)

**Type**: Boolean**Availability**: Used only for KSDFT with plane wave basis**Description**: Controls the generation of machine learning training data. When enabled, training data in`.npy`

format will be saved in the directory`OUT.${suffix}/MLKEDF_Descriptors/`

. The generated descriptors are categorized as follows:`{var}.npy`

, where`{var}`

corresponds to the descriptor type:`gamma`

: Enabled by[of_ml_gamma](#of-ml-gamma)`p`

: Enabled by[of_ml_p](#of-ml-p)`q`

: Enabled by[of_ml_q](#of-ml-q)`tanhp`

: Enabled by[of_ml_tanhp](#of-ml-tanhp)`tanhq`

: Enabled by[of_ml_tanhq](#of-ml-tanhq)

[of_ml_nkernel](#of-ml-nkernel),[of_ml_kernel](#of-ml-kernel), and[of_ml_kernel_scaling](#of-ml-kernel-scaling). Files follow the naming convention`{var}_{kernel_type}_{kernel_scaling}.npy`

, where`{kernel_type}`

and`{kernel_scaling}`

are specified by[of_ml_kernel](#of-ml-kernel), and[of_ml_kernel_scaling](#of-ml-kernel-scaling), respectively, and`{val}`

denotes the kind of the descriptor, including`gammanl`

: Enabled by[of_ml_gammanl](#of-ml-gammanl)`pnl`

: Enabled by[of_ml_pnl](#of-ml-pnl)`qnl`

: Enabled by[of_ml_qnl](#of-ml-qnl)`xi`

: Enabled by[of_ml_xi](#of-ml-xi)`tanhxi`

: Enabled by[of_ml_tanhxi](#of-ml-tanhxi)`tanhxi_nl`

: Enabled by[of_ml_tanhxi_nl](#of-ml-tanhxi-nl)`tanh_pnl`

: Enabled by[of_ml_tanh_pnl](#of-ml-tanh-pnl)`tanh_qnl`

: Enabled by[of_ml_tanh_qnl](#of-ml-tanh-qnl)`tanhp_nl`

: Enabled by[of_ml_tanhp_nl](#of-ml-tanhp-nl)`tanhq_nl`

: Enabled by[of_ml_tanhq_nl](#of-ml-tanhq-nl)

Training Targets, including key quantum mechanical quantities:

`enhancement.npy`

: Pauli energy enhancement factor \(T_\theta/T_{\rm{TF}}\), where \(T_{\rm{TF}}\) is the Thomas-Fermi functional`pauli.npy`

: Pauli potential \(V_\theta\)`veff.npy`

: Effective potential


**Default**: False

### of_ml_device[#](#of-ml-device)

**Type**: String**Availability**: OFDFT**Description**: Run Neural Network on GPU or CPU.**cpu**: CPU**gpu**: GPU

**Default**: cpu

### of_ml_feg[#](#of-ml-feg)

**Type**: Integer**Availability**: OFDFT**Description**: The method to incorporate the Free Electron Gas (FEG) limit: \(F_\theta |_{\rm{FEG}} = 1\), where \(F_\theta\) is enhancement factor of Pauli energy.**0**: Do not incorporate the FEG limit.**1**: Incorporate the FEG limit by translation: \(F_\theta = F^{\rm{NN}}_\theta - F^{\rm{NN}}_\theta|_{\rm{FEG}} + 1\).**3**: Incorporate the FEG limit by nonlinear transformation: \(F_\theta = f(F^{\rm{NN}}_\theta - F^{\rm{NN}}_\theta|_{\rm{FEG}} + \ln(e - 1))\), where \(f = \ln(1 + e^x)\) is softplus function, satisfying \(f(x)|_{x=\ln(e-1)} = 1\).

**Default**: 0

### of_ml_nkernel[#](#of-ml-nkernel)

**Type**: Integer**Availability**: OFDFT**Description**: Number of kernel functions.**Default**: 1

### of_ml_kernel[#](#of-ml-kernel)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the type of the \(i\)-th kernel function.**1**: Wang-Teter kernel function.**2**: Modified Yukawa function: \(k_{\rm{F}}^2\frac{\exp{({-\alpha k_{\rm{F}}|\mathbf{r}-\mathbf{r}'|})}}{|\mathbf{r}-\mathbf{r}'|}\), and \(\alpha\) is specified by[of_ml_yukawa_alpha](#of-ml-yukawa-alpha).**3**: Truncated kinetic kernel (TKK), the file containing TKK is specified by[of_ml_kernel_file](#of-kernel-file).

**Default**: 1

### of_ml_kernel_scaling[#](#of-ml-kernel-scaling)

**Type**: Vector of Real**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the RECIPROCAL of scaling parameter \(\lambda\) of the \(i\)-th kernel function. \(w_i(\mathbf{r}-\mathbf{r}') = \lambda^3 w_i'(\lambda(\mathbf{r}-\mathbf{r}'))\).**Default**: 1.0

### of_ml_yukawa_alpha[#](#of-ml-yukawa-alpha)

**Type**: Vector of Real**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the parameter \(\alpha\) of \(i\)-th kernel function. ONLY used for Yukawa kernel function.**Default**: 1.0

### of_ml_kernel_file[#](#of-ml-kernel-file)

**Type**: Vector of String**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the file containint the \(i\)-th kernel function. ONLY used for TKK.**Default**: none

### of_ml_gamma[#](#of-ml-gamma)

**Type**: Boolean**Availability**: OFDFT**Description**: Local descriptor: \(\gamma(\mathbf{r}) = (\rho(\mathbf{r}) / \rho_0)^{1/3}\).**Default**: False

### of_ml_p[#](#of-ml-p)

**Type**: Boolean**Availability**: OFDFT**Description**: Semi-local descriptor: \(p(\mathbf{r}) = \frac{|\nabla \rho(\mathbf{r})|^2} {[2 (3 \pi^2)^{1/3} \rho^{4/3}(\mathbf{r})]^2}\).**Default**: False

### of_ml_q[#](#of-ml-q)

**Type**: Boolean**Availability**: OFDFT**Description**: Semi-local descriptor: \(q(\mathbf{r}) = \frac{\nabla^2 \rho(\mathbf{r})} {[4 (3 \pi^2)^{2/3} \rho^{5/3}(\mathbf{r})]}\).**Default**: False

### of_ml_tanhp[#](#of-ml-tanhp)

**Type**: Boolean**Availability**: OFDFT**Description**: Semi-local descriptor: \(\tilde{p}(\mathbf{r}) = \tanh(\chi_p p(\mathbf{r}))\).**Default**: False

### of_ml_tanhq[#](#of-ml-tanhq)

**Type**: Boolean**Availability**: OFDFT**Description**: Semi-local descriptor: \(\tilde{q}(\mathbf{r}) = \tanh(\chi_q q(\mathbf{r}))\).**Default**: False

### of_ml_chi_p[#](#of-ml-chi-p)

**Type**: Real**Availability**: OFDFT**Description**: Hyperparameter \(\chi_p\): \(\tilde{p}(\mathbf{r}) = \tanh(\chi_p p(\mathbf{r}))\).**Default**: 1.0

### of_ml_chi_q[#](#of-ml-chi-q)

**Type**: Real**Availability**: OFDFT**Description**: Hyperparameter \(\chi_q\): \(\tilde{q}(\mathbf{r}) = \tanh(\chi_q q(\mathbf{r}))\).**Default**: False

### of_ml_gammanl[#](#of-ml-gammanl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\gamma_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') \gamma(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_pnl[#](#of-ml-pnl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(p_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') p(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_qnl[#](#of-ml-qnl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(q_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') q(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_xi[#](#of-ml-xi)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\xi(\mathbf{r}) = \frac{\int{w_i(\mathbf{r}-\mathbf{r}') \rho^{1/3}(\mathbf{r}') dr'}}{\rho^{1/3}(\mathbf{r})}\).**Default**: 0

### of_ml_tanhxi[#](#of-ml-tanhxi)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{\xi}(\mathbf{r}) = \tanh(\chi_{\xi} \xi(\mathbf{r}))\).**Default**: 0

### of_ml_tanhxi_nl[#](#of-ml-tanhxi-nl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{\xi}_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') \tilde{\xi}(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_tanh_pnl[#](#of-ml-tanh-pnl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{p_{\rm{nl}}}(\mathbf{r}) = \tanh{(\chi_{p_{\rm{nl}}} p_{\rm{nl}}(\mathbf{r}))}\).**Default**: 0

### of_ml_tanh_qnl[#](#of-ml-tanh-qnl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{q_{\rm{nl}}}(\mathbf{r}) = \tanh{(\chi_{q_{\rm{nl}}} q_{\rm{nl}}(\mathbf{r}))}\).**Default**: 0

### of_ml_tanhp_nl[#](#of-ml-tanhp-nl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{p}_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') \tilde{p}(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_tanhq_nl[#](#of-ml-tanhq-nl)

**Type**: Vector of Integer**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element controls the non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{q}_{\rm{nl}}(\mathbf{r}) = \int{w_i(\mathbf{r}-\mathbf{r}') \tilde{q}(\mathbf{r}') dr'}\).**Default**: 0

### of_ml_chi_xi[#](#of-ml-chi-xi)

**Type**: Vector of Real**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the hyperparameter \(\chi_\xi\) of non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{\xi}(\mathbf{r}) = \tanh(\chi_{\xi} \xi(\mathbf{r}))\).**Default**: 1.0

### of_ml_chi_pnl[#](#of-ml-chi-pnl)

**Type**: Vector of Real**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the hyperparameter \(\chi_{p_{\rm{nl}}}\) of non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{p_{\rm{nl}}}(\mathbf{r}) = \tanh{(\chi_{p_{\rm{nl}}} p_{\rm{nl}}(\mathbf{r}))}\).**Default**: 1.0

### of_ml_chi_qnl[#](#of-ml-chi-qnl)

**Type**: Vector of Real**Availability**: OFDFT**Description**: Containing nkernel (see[of_ml_nkernel](#of-ml-nkernel)) elements. The \(i\)-th element specifies the hyperparameter \(\chi_{q_{\rm{nl}}}\) of non-local descriptor defined by the \(i\)-th kernel function \(w_i(\mathbf{r}-\mathbf{r}')\): \(\tilde{q_{\rm{nl}}}(\mathbf{r}) = \tanh{(\chi_{q_{\rm{nl}}} q_{\rm{nl}}(\mathbf{r}))}\).**Default**: 1.0

### of_ml_local_test[#](#of-ml-local-test)

**Type**: Boolean**Availability**: OFDFT**Description**: FOR TEST. Read in the density, and output the F and Pauli potential.**Default**: False

## TDOFDFT: time dependent orbital free density functional theory[#](#tdofdft-time-dependent-orbital-free-density-functional-theory)

### of_cd[#](#of-cd)

**Type**: Boolean**Availability**: TDOFDFT**Type**: Boolean**Description**: Added the current dependent(CD) potential. ([https://doi.org/10.1103/PhysRevB.98.144302](https://doi.org/10.1103/PhysRevB.98.144302))True: Added the CD potential.

False: Not added the CD potential.


**Default**: False

### of_mcd_alpha[#](#of-mcd-alpha)

**Type**: Real**Availability**: TDOFDFT**Description**: The value of the parameter alpha in modified CD potential method. mCDPotenial=alpha*CDPotenial(proposed in paper PhysRevB.98.144302)**Default**: 1.0

## Electric field and dipole correction[#](#electric-field-and-dipole-correction)

These variables are relevant to electric field and dipole correction

### efield_flag[#](#efield-flag)

**Type**: Boolean**Description**: Added the electric field.True: A saw-like potential simulating an electric field is added to the bare ionic potential.

False: Not added the electric field.


**Default**: False

### dip_cor_flag[#](#dip-cor-flag)

**Type**: Boolean**Availability**: With dip_cor_flag = True and efield_flag = True.**Description**: Added a dipole correction to the bare ionic potential.True：A dipole correction is also added to the bare ionic potential.

False: A dipole correction is not added to the bare ionic potential.



`efield_amp`

should be set to zero. This should ONLY be used in a slab geometry for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE.

**Default**: False

### efield_dir[#](#efield-dir)

**Type**: Integer**Availability**: with efield_flag = True.**Description**: The direction of the electric field or dipole correction is parallel to the reciprocal lattice vector, so the potential is constant in planes defined by FFT grid points, efield_dir can set to 0, 1 or 2.0: parallel to \(b_1=\frac{2\pi(a_2\times a_3)}{a_1\cdot(a_2\times a_3)}\)

1: parallel to \(b_2=\frac{2\pi(a_3\times a_1)}{a_1\cdot(a_2\times a_3)}\)

2: parallel to \(b_3=\frac{2\pi(a_1\times a_2)}{a_1\cdot(a_2\times a_3)}\)


**Default**: 2

### efield_pos_max[#](#efield-pos-max)

**Type**: Real**Availability**: with efield_flag = True.**Description**: Position of the maximum of the saw-like potential along crystal axis efield_dir, within the unit cell, 0 <= efield_pos_max < 1.**Default**: Autoset to`center of vacuum - width of vacuum / 20`


### efield_pos_dec[#](#efield-pos-dec)

**Type**: Real**Availability**: with efield_flag = True.**Description**: Zone in the unit cell where the saw-like potential decreases, 0 < efield_pos_dec < 1.**Default**: Autoset to`width of vacuum / 10`


### efield_amp[#](#efield-amp)

**Type**: Real**Availability**: with efield_flag = True.**Description**: Amplitude of the electric field. The saw-like potential increases with slope efield_amp in the region from efield_pos_max+efield_pos_dec-1) to (efield_pos_max), then decreases until (efield_pos_max+efield_pos_dec), in units of the crystal vector efield_dir.

**Default**: 0.0**Unit**: a.u., 1 a.u. = 51.4220632*10^10 V/m.

## Gate field (compensating charge)[#](#gate-field-compensating-charge)

These variables are relevant to gate field (compensating charge) [Detailed introduction](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/scf/advanced.md#compensating-charge)

### gate_flag[#](#gate-flag)

**Type**: Boolean**Description**: Controls the addition of compensating charge by a charged plate for charged cells.**zgate**position to add compensating charge. The direction is determined by**efield_dir**.false: No compensating charge is added.


**Default**: false

### zgate[#](#zgate)

**Type**: Real**Description**: Position of the charged plate in the unit cell**Unit**: Unit cell size**Default**: 0.5**Constraints**: 0 <=**zgate**< 1

### block[#](#block)

**Type**: Boolean**Description**: Controls the addition of a potential barrier to prevent electron spillover.**block_down**to**block_up**with a height of**block_height**. If**dip_cor_flag**is set to true,**efield_pos_dec**is used to smoothly increase and decrease the potential barrier.false: No potential barrier is added.


**Default**: false

### block_down[#](#block-down)

**Type**: Real**Description**: Lower beginning of the potential barrier**Unit**: Unit cell size**Default**: 0.45**Constraints**: 0 <=**block_down**<**block_up**< 1

### block_up[#](#block-up)

**Type**: Real**Description**: Upper beginning of the potential barrier**Unit**: Unit cell size**Default**: 0.55**Constraints**: 0 <=**block_down**<**block_up**< 1

### block_height[#](#block-height)

**Type**: Real**Description**: Height of the potential barrier**Unit**: Rydberg**Default**: 0.1

## Exact Exchange (Common)[#](#exact-exchange-common)

* basis_type==lcao/lcao_in_pw*. Support for hybrid functionals in the

*pw*is under active development.

[basis_type](#basis-type)* basis_type==lcao/lcao_in_pw/pw*. For basis specific parameters, see the sections

*and*

[Exact Exchange (LCAO/LCAO in PW)](#exact-exchange-lcaolcao-in-pw)*.*

[Exact Exchange (PW)](#exact-exchange-pw)### Hybrid Functional Parameters {#hybrid_func_params}[#](#hybrid-functional-parameters-hybrid-func-params)

hf | 1 | 0 | 0 |
lc_pbe | 1 | -1 | 0.33 |
lc_wpbe | 1 | -1 | 0.4 |
lrc_wpbe | 1 | -1 | 0.3 |
lrc_wpbeh | 1 | -0.8 | 0.2 |
pbe0 | 0.25 | 0 | 0 |
hse | 0.0 | 0.25 | 0.11 |
scan0 | 0.25 | 0 | 0 |
cam_pbeh | 0.2 | 0.8 | 0.7 |
b3lyp | 0.2 | 0 | 0 |
muller | 1 | 0 | 0 |
power | 1 | 0 | 0 |
wp22 | 1 | -1 | 0.11 |
cwp22 | 0 | 1 | 0.11 |

### exx_fock_alpha[#](#exx-fock-alpha)

**Type**: Real [Real…](optional)**Description**: Fraction of full-ranged Fock exchange 1/r (\(\alpha\)) in range-separated hybrid funtionals, so that \(E_{X} = \alpha E_{X}^\text{HF-LR}+(\alpha+\beta) E_{X}^\text{HF-SR}+(1-\alpha)E_{X}^\text{KS-LR}+[1-(\alpha+\beta)]E_{X}^\text{KS-SR}\).**Default**: see[hybrid_func_params](#hybrid_func_params)

### exx_erfc_alpha[#](#exx-erfc-alpha)

**Type**: Real [Real…](optional)**Description**: Fraction of short-ranged Fock exchange erfc(wr)/r (\(\beta\)) in range-separated hybrid funtionals, so that \(E_{X} = \alpha E_{X}^\text{HF-LR}+(\alpha+\beta) E_{X}^\text{HF-SR}+(1-\alpha)E_{X}^\text{KS-LR}+[1-(\alpha+\beta)]E_{X}^\text{KS-SR}\).**Default**: see[hybrid_func_params](#hybrid_func_params)

### exx_erfc_omega[#](#exx-erfc-omega)

**Type**: Real [Real…](optional)**Description**: Range-separation parameter in exchange, such that \(1/r=\text{erfc}(\omega r)/r+\text{erf}(\omega r)/r\)**Default**: see[hybrid_func_params](#hybrid_func_params)

### exx_separate_loop[#](#exx-separate-loop)

**Type**: Boolean**Description**: There are two types of iterative approaches provided by ABACUS to evaluate Fock exchange.**Default**: True

### exx_hybrid_step[#](#exx-hybrid-step)

**Type**: Integer**Availability**:[exx_separate_loop](#exx-separate-loop)==1**Description**: The maximal iteration number of the outer-loop, where the Fock exchange is calculated**Default**: 100

### exx_mixing_beta[#](#exx-mixing-beta)

**Type**: Real**Availability**:[exx_separate_loop](#exx-separate-loop)==1**Description**: Mixing parameter for densty matrix in each iteration of the outer-loop**Default**: 1.0

## Exact Exchange (LCAO in PW)[#](#exact-exchange-lcao-in-pw)

These variables are relevant when using hybrid functionals with * basis_type==lcao/lcao_in_pw*.

### exx_fock_lambda[#](#exx-fock-lambda)

**Type**: Real [Real…](optional)**Availability**:[basis_type](#basis-type)==lcao_in_pw**Description**: It is used to compensate for divergence points at G=0 in the evaluation of Fock exchange using*lcao_in_pw*method.**Default**: 0.3

## Exact Exchange (LCAO)[#](#exact-exchange-lcao)

These variables are relevant when using hybrid functionals with * basis_type==lcao/lcao_in_pw*.

### exx_pca_threshold[#](#exx-pca-threshold)

**Type**: Real**Description**: To accelerate the evaluation of four-center integrals (\(ik|jl\)), the product of atomic orbitals are expanded in the basis of auxiliary basis functions (ABF): \(\Phi_{i}\Phi_{k}\sim \sum_{a} C^{a}_{ik}P_{a}\). The size of the ABF (i.e. number of \(P_{a}\)) is reduced using principal component analysis. When a large PCA threshold is used, the number of ABF will be reduced, hence the calculation becomes faster. However, this comes at the cost of computational accuracy. A relatively safe choice of the value is 1e-4.**Default**: 1E-4

### exx_c_threshold[#](#exx-c-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). Smaller components (less than exx_c_threshold) of the \(C^{a}_{ik}\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.**Default**: 1E-4

### exx_cs_inv_thr[#](#exx-cs-inv-thr)

**Type**: Real**Description**: By default, the Coulomb matrix inversion required for obtaining LRI coefficients is performed using LU decomposition. However, this approach may suffer from numerical instabilities when a large set of auxiliary basis functions (ABFs) is employed. When`exx_cs_inv_thr > 0`

, the inversion is instead carried out via matrix diagonalization. Eigenvalues smaller than`exx_cs_inv_thr`

are discarded to improve numerical stability. A relatively safe and commonly recommended value is`1e-5`

.**Default**: -1

### exx_v_threshold[#](#exx-v-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). With the approximation \(\Phi_{i}\Phi_{k}\sim \sum_{a} C^{a}_{ik}P_{a}\), the four-center integral in Fock exchange is expressed as \((ik|jl)=\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\), where \(V_{ab}=(P_{a}|P_{b})\) is a double-center integral. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.**Default**: 1E-1

### exx_dm_threshold[#](#exx-dm-threshold)

**Type**: Real**Description**: The Fock exchange can be expressed as \(\sum_{k,l}(ik|jl)D_{kl}\) where D is the density matrix. Smaller values of the density matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.**Default**: 1E-4

### exx_c_grad_threshold[#](#exx-c-grad-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). \(\nabla C^{a}_{ik}\) is used in force. Smaller components (less than exx_c_grad_threshold) of the \(\nabla C^{a}_{ik}\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.**Default**: 1E-4

### exx_v_grad_threshold[#](#exx-v-grad-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). With the approximation \(\Phi_{i}\Phi_{k}\sim C^{a}_{ik}P_{a}\), the four-center integral in Fock exchange is expressed as \((ik|jl)=\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\), where \(V_{ab}=(P_{a}|P_{b})\) is a double-center integral. \(\nabla V_{ab}\) is used in force. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.**Default**: 1E-1

### exx_c_grad_r_threshold[#](#exx-c-grad-r-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). \(\nabla C^{a}_{ik} * R_{ik}\) is used in stress. Smaller components (less than exx_c_grad_r_threshold) of the \(\nabla C^{a}_{ik} * R_{ik}\) matrix are neglected to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 1e-4.**Default**: 1E-4

### exx_v_grad_r_threshold[#](#exx-v-grad-r-threshold)

**Type**: Real**Description**: See also the entry[exx_pca_threshold](#exx-pca-threshold). With the approximation \(\Phi_{i}\Phi_{k}\sim C^{a}_{ik}P_{a}\), the four-center integral in Fock exchange is expressed as \((ik|jl)=\sum_{a,b}C^{a}_{ik}V_{ab}C^{b}_{jl}\), where \(V_{ab}=(P_{a}|P_{b})\) is a double-center integral. \(\nabla V_{ab} *R_{ab}\) is used in force and stress. Smaller values of the V matrix can be truncated to accelerate calculation. The larger the threshold is, the faster the calculation and the lower the accuracy. A relatively safe choice of the value is 0, i.e. no truncation.**Default**: 1E-1

### exx_ccp_threshold[#](#exx-ccp-threshold)

**Type**: Real**Description**: It is related to the cutoff of on-site Coulomb potentials. (Currently not used)**Default**: 1e-8

### exx_ccp_rmesh_times[#](#exx-ccp-rmesh-times)

**Type**: Real**Description**: This parameter determines how many times larger the radial mesh required for calculating Columb potential is to that of atomic orbitals. The value should be larger than 0. Reducing this value can effectively increase the speed of self-consistent calculations using hybrid functionals.**Default**:5: if

[dft_functional](#dft-functional)==hf/pbe0/scan0/muller/power/wp221.5: if

[dft_functional](#dft-functional)==hse/cwp221: else



### exx_opt_orb_lmax[#](#exx-opt-orb-lmax)

**Type**: Integer**Availability**:[calculation](#calculation)==gen_opt_abfs**Description**: The maximum l of the spherical Bessel functions, when the radial part of opt-ABFs are generated as linear combinations of spherical Bessel functions. A reasonable choice is 2.**Default**: 0

### exx_opt_orb_ecut[#](#exx-opt-orb-ecut)

**Type**: Real**Availability**:[calculation](#calculation)==gen_opt_abfs**Description**: The cut-off of plane wave expansion, when the plane wave basis is used to optimize the radial ABFs. A reasonable choice is 60.**Default**: 0**Unit**: Ry

### exx_opt_orb_tolerence[#](#exx-opt-orb-tolerence)

**Type**: Real**Availability**:[calculation](#calculation)==gen_opt_abfs**Description**: The threshold when solving for the zeros of spherical Bessel functions. A reasonable choice is 1e-12.**Default**: 1E-12

### exx_real_number[#](#exx-real-number)

**Type**: Boolean**Description**:True: Enforce LibRI to use

`double`

data type.`complex`

data type. Setting it to True can effectively improve the speed of self-consistent calculations with hybrid functionals.

**Default**: depends on the[gamma_only](#gamma-only)optionTrue: if gamma_only

False: else



### exx_singularity_correction[#](#exx-singularity-correction)

**Type**: String**Description**:spencer: see Phys. Rev. B 77, 193110 (2008).


**Default**: default

### rpa_ccp_rmesh_times[#](#rpa-ccp-rmesh-times)

**Type**: Real**Description**: How many times larger the radial mesh required is to that of atomic orbitals in the postprocess calculation of the**bare**Coulomb matrix for RPA, GW, etc.**Default**: 10

### exx_symmetry_realspace[#](#exx-symmetry-realspace)

**Type**: Boolean**Availability**:and exx calculation ([symmetry](#symmetry)==1or[dft_fuctional](#dft-functional)==hse/hf/pbe0/scan0)[rpa](#rpa)==True**Description**:True: rotate both D(k) and Hexx® to accelerate both diagonalization and EXX calculation


**Default**: True

### out_ri_cv[#](#out-ri-cv)

**Type**: Boolean**Description**: Whether to output the coefficient tensor C® and ABFs-representation Coulomb matrix V® for each atom pair and cell in real space.**Default**: false

## Exact Exchange (PW)[#](#exact-exchange-pw)

* basis_type==pw*. Note that hybrid functionals in

*is under active development, and currently limited to*

[basis_type](#basis-type)==pw*and **

[nspin](#nspin)== 1 or 2[symmetry](#symmetry)==-1

### exxace[#](#exxace)

**Type**: Boolean**Availability**:.[exx_separate_loop](#exx-separate-loop)==True**Description**: Whether to use the ACE method ([https://doi.org/10.1021/acs.jctc.6b00092](https://doi.org/10.1021/acs.jctc.6b00092)) to accelerate the calculation the Fock exchange matrix. Should be set to true most of the time.True: Use the ACE method to calculate the Fock exchange operator.

False: Use the traditional method to calculate the Fock exchange operator.


**Default**: True

### exx_gamma_extrapolation[#](#exx-gamma-extrapolation)

**Type**: Boolean**Description**: Whether to use the gamma point extrapolation method to calculate the Fock exchange operator. See[https://doi.org/10.1103/PhysRevB.79.205114](https://doi.org/10.1103/PhysRevB.79.205114)for details. Should be set to true most of the time.**Default**: True

### ecutexx[#](#ecutexx)

**Type**: Real**Description**: The energy cutoff for EXX (Fock) exchange operator in plane wave basis calculations. Reducing`ecutexx`

below`ecutrho`

may significantly accelerate EXX computations. This speed improvement comes with a reduced numerical accuracy in the exchange energy calculation.**Default**: same as[ecutrho](#ecutrho)**Unit**: Ry

### exx_thr_type[#](#exx-thr-type)

**Type**: String**Description**: The type of threshold used to judge whether the outer loop has converged in the separate loop EXX calculation.energy: use the change of exact exchange energy to judge convergence.

, then the outer loop is seen as converged.[scf_thr](#scf-thr)

**Default**:`density`


### exx_ene_thr[#](#exx-ene-thr)

**Type**: Real**Availability**:==[exx_thr_type](#exx-thr-type)`energy`

**Description**: The threshold for the change of exact exchange energy to judge convergence of the outer loop in the separate loop EXX calculation.**Default**: 1e-5**Unit**: Ry

## Molecular dynamics[#](#molecular-dynamics)

[md.md](../md.html#molecular-dynamics) in detail.

### md_type[#](#md-type)

**Type**: String**Description**: Control the algorithm to integrate the equation of motion for molecular dynamics (MD), see[md.md](../md.html#molecular-dynamics)in detail.fire: a MD-based relaxation algorithm, named fast inertial relaxation engine.

nve: NVE ensemble with velocity Verlet algorithm.

nvt: NVT ensemble, see

[md_thermostat](#md-thermostat)in detail.npt: Nose-Hoover style NPT ensemble, see

[md_pmode](#md-pmode)in detail.langevin: NVT ensemble with Langevin thermostat, see

[md_damp](#md-damp)in detail.msst: MSST method, see

[msst_direction](#msst-direction),[msst_vel](#msst-vel),[msst_qmass](#msst-qmass),[msst_vis](#msst-vis),[msst_tscale](#msst-tscale)in detail.

**Default**: nvt

### md_nstep[#](#md-nstep)

**Type**: Integer**Description**: The total number of molecular dynamics steps.**Default**: 10

### md_dt[#](#md-dt)

**Type**: Real**Description**: The time step used in molecular dynamics calculations.**Default**: 1.0**Unit**: fs

### md_thermostat[#](#md-thermostat)

**Type**: String**Description**: Specify the temperature control method used in NVT ensemble.nhc: Nose-Hoover chain, see

[md_tfreq](#md-tfreq)and[md_tchain](#md-tchain)in detail.anderson: Anderson thermostat, see

[md_nraise](#md-nraise)in detail.berendsen: Berendsen thermostat, see

[md_nraise](#md-nraise)in detail.rescaling: velocity Rescaling method 1, see

[md_tolerance](#md-tolerance)in detail.rescale_v: velocity Rescaling method 2, see

[md_nraise](#md-nraise)in detail.

**Default**: nhc

### md_tfirst, md_tlast[#](#md-tfirst-md-tlast)

**Type**: Real**Description**: The temperature used in molecular dynamics calculations.`md_tfirst`

is unset or less than zero,[init_vel](#init-vel)is autoset to be`true`

. If[init_vel](#init-vel)is`true`

, the initial temperature will be determined by the velocities read from`STRU`

. In this case, if velocities are unspecified in`STRU`

, the initial temperature is set to zero.`md_tfirst`

is set to a positive value and[init_vel](#init-vel)is`true`

simultaneously, please make sure they are consistent, otherwise abacus will exit immediately.`md_tlast`

is only used in NVT/NPT simulations. If`md_tlast`

is unset or less than zero,`md_tlast`

is set to`md_tfirst`

. If`md_tlast`

is set to be different from`md_tfirst`

, ABACUS will automatically change the temperature from`md_tfirst`

to`md_tlast`

.**Default**: No default**Unit**: K

### md_restart[#](#md-restart)

**Type**: Boolean**Description**: Control whether to restart molecular dynamics calculations and time-dependent density functional theory calculations.`${read_file_dir}/Restart_md.txt`

to determine the current step`${md_step}`

, then read in the corresponding`STRU_MD_${md_step}`

in the folder`OUT.$suffix/STRU/`

automatically. For tddft, ABACUS will also read in`WFC_NAO_K${kpoint}`

of the last step (You need to set out_wfc_lcao=1 and out_app_flag=0 to obtain this file).False: ABACUS will start molecular dynamics calculations normally from the first step.


**Default**: False

### md_restartfreq[#](#md-restartfreq)

**Type**: Integer**Description**: The output frequency of`OUT.${suffix}/Restart_md.txt`

and structural files in the directory`OUT.${suffix}/STRIU/`

, which are used to restart molecular dynamics calculations, see[md_restart](#md-restart)in detail.**Default**: 5

### md_dumpfreq[#](#md-dumpfreq)

**Type**: Integer**Description**: The output frequency of`OUT.${suffix}/MD_dump`

in molecular dynamics calculations, which including the information of lattices and atoms.**Default**: 1

### dump_force[#](#dump-force)

**Type**: Boolean**Description**: Whether to output atomic forces into the file`OUT.${suffix}/MD_dump`

.**Default**: True

### dump_vel[#](#dump-vel)

**Type**: Boolean**Description**: Whether to output atomic velocities into the file`OUT.${suffix}/MD_dump`

.**Default**: True

### dump_virial[#](#dump-virial)

**Type**: Boolean**Description**: Whether to output lattice virials into the file`OUT.${suffix}/MD_dump`

.**Default**: True

### md_seed[#](#md-seed)

**Type**: Integer**Description**: The random seed to initialize random numbers used in molecular dynamics calculations.< 0: No srand() function is called.

>= 0: The function srand(md_seed) is called.


**Default**: -1

### md_tfreq[#](#md-tfreq)

**Type**: Real**Description**: Control the frequency of temperature oscillations during the simulation. If it is too large, the temperature will fluctuate violently; if it is too small, the temperature will take a very long time to equilibrate with the atomic system.**Default**: 1/40/md_dt**Unit**: \(\mathrm{fs^{-1}}\)

### md_tchain[#](#md-tchain)

**Type**: Integer**Description**: Number of thermostats coupled with the particles in the NVT/NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.**Default**: 1

### md_pmode[#](#md-pmode)

**Type**: String**Description**: Specify the cell fluctuation mode in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.iso: The three diagonal elements of the lattice are fluctuated isotropically.

aniso: The three diagonal elements of the lattice are fluctuated anisotropically.

tri: The lattice must be a lower-triangular matrix, and all six freedoms are fluctuated.


**Default**: iso**Relavent**:[md_tfreq](#md-tfreq),[md_tchain](#md-tchain),[md_pcouple](#md-pcouple),[md_pfreq](#md-pfreq), and[md_pchain](#md-pchain).

### ref_cell_factor[#](#ref-cell-factor)

**Type**: Real**Description**: Construct a reference cell bigger than the initial cell. The reference cell has to be large enough so that the lattice vectors of the fluctuating cell do not exceed the reference lattice vectors during MD. Typically, 1.02 ~ 1.10 is sufficient. However, the cell fluctuations depend on the specific system and thermodynamic conditions. So users must test for a proper choice. This parameters should be used in conjunction with[erf_ecut](#erf-ecut),[erf_height](#erf-height), and[erf_sigma](#erf-sigma).**Default**: 1.0

### md_pcouple[#](#md-pcouple)

**Type**: String**Description**: The coupled lattice vectors will scale proportionally in NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.none: Three lattice vectors scale independently.

xyz: Lattice vectors x, y, and z scale proportionally.

xy: Lattice vectors x and y scale proportionally.

xz: Lattice vectors x and z scale proportionally.

yz: Lattice vectors y and z scale proportionally.


**Default**: none

### md_pfirst, md_plast[#](#md-pfirst-md-plast)

**Type**: Real**Description**: The target pressure used in NPT ensemble simulations, the default value of`md_plast`

is`md_pfirst`

. If`md_plast`

is set to be different from`md_pfirst`

, ABACUS will automatically change the target pressure from`md_pfirst`

to`md_plast`

.**Default**: -1.0**Unit**: kbar

### md_pfreq[#](#md-pfreq)

**Type**: Real**Description**: The frequency of pressure oscillations during the NPT ensemble simulation. If it is too large, the pressure will fluctuate violently; if it is too small, the pressure will take a very long time to equilibrate with the atomic system.**Default**: 1/400/md_dt**Unit**: \(\mathrm{kbar^{-1}}\)

### md_pchain[#](#md-pchain)

**Type**: Integer**Description**: The number of thermostats coupled with the barostat in the NPT ensemble based on the Nose-Hoover style non-Hamiltonian equations of motion.**Default**: 1

### lj_rule[#](#lj-rule)

**Type**: Integer**Description**: The Lennard-Jones potential between two atoms equals: $\(V_{LJ}(r_{ij})=4\epsilon_{ij}\left(\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{12}-\left(\frac{\sigma_{ij}}{r_{ij}}\right)^{6}\right)=\frac{C_{ij}^{(12)}}{{r_{ij}}^{12}}-\frac{C_{ij}^{(6)}}{{r_{ij}}^{6}}.\)$[lj_epsilon](#lj-epsilon)and[lj_sigma](#lj-sigma)should be multiple-component vectors. For example, there are two choices in the calculations of 3 atom species:**Default**: 2

### lj_eshift[#](#lj-eshift)

**Type**: Boolean**Description**: It True, the LJ potential is shifted by a constant such that it is zero at the cut-off distance.**Default**: False

### lj_rcut[#](#lj-rcut)

**Type**: Real**Description**: Cut-off radius for Leonard Jones potential, beyond which the interaction will be neglected. It can be a single value, which means that all pairs of atoms types share the same cut-off radius. Otherwise, it should be a multiple-component vector, containing \(N(N+1)/2\) values, see details in[lj_rule](#lj-rule).**Default**: No default**Unit**: Angstrom

### lj_epsilon[#](#lj-epsilon)

**Type**: Real**Description**: The vector representing the \(\epsilon\) matrix for Leonard Jones potential. See details in[lj_rule](#lj-rule).**Default**: No default**Unit**: eV

### lj_sigma[#](#lj-sigma)

**Type**: Real**Description**: The vector representing the \(\sigma\) matrix for Leonard Jones potential. See details in[lj_rule](#lj-rule).**Default**: No default**Unit**: Angstrom

### pot_file[#](#pot-file)

**Type**: String**Description**: The filename of DP/NEP potential files, see[md.md](../md.html#dpmd)in detail.**Default**: graph.pb

### dp_rescaling[#](#dp-rescaling)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`dp`

.**Description**: Rescaling factor to use a temperature-dependent DP. Energy, stress and force calculated by DP will be multiplied by this factor.**Default**: 1.0

### dp_fparam[#](#dp-fparam)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`dp`

.**Description**: The frame parameter for dp potential. The array size is dim_fparam, then all frames are assumed to be provided with the same fparam.**Default**: {}

### dp_aparam[#](#dp-aparam)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`dp`

.**Description**: The atomic parameter for dp potential. The array size can be (1) natoms x dim_aparam, then all frames are assumed to be provided with the same aparam; (2) dim_aparam, then all frames and atoms are assumed to be provided with the same aparam.**Default**: {}

### msst_direction[#](#msst-direction)

**Type**: Integer**Description**: The direction of the shock wave in the MSST method.0: x direction

1: y direction

2: z direction


**Default**: 2

### msst_vel[#](#msst-vel)

**Type**: Real**Description**: The velocity of the shock wave in the MSST method.**Default**: 0.0**Unit**: Angstrom/fs

### msst_vis[#](#msst-vis)

**Type**: Real**Description**: Artificial viscosity in the MSST method.**Default**: 0.0**Unit**: g/(mol*Angstrom*fs)

### msst_tscale[#](#msst-tscale)

**Type**: Real**Description**: The reduction percentage of the initial temperature used to compress volume in the MSST method.**Default**: 0.01

### msst_qmass[#](#msst-qmass)

**Type**: Real**Description**: Inertia of the extended system variable. You should set a number larger than 0.**Default**: No default**Unit**: \(\mathrm{g^{2}/(mol^{2}*Angstrom^{4})}\)

### md_damp[#](#md-damp)

**Type**: Real**Description**: The damping parameter used to add fictitious force in the Langevin method.**Default**: 1.0**Unit**: fs

### md_tolerance[#](#md-tolerance)

**Type**: Real**Description**: The temperature tolerance for velocity rescaling. Velocities are rescaled if the current and target temperature differ more than`md_tolerance`

.**Default**: 100.0**Unit**: K

### md_nraise[#](#md-nraise)

**Type**: Integer**Description**:Anderson: The “collision frequency” parameter is given as 1/

`md_nraise`

.`md_nraise`

*`md_dt`

, so`md_dt`

/tau = 1/`md_nraise`

.Rescale_v: Every

`md_nraise`

steps the current temperature is rescaled to the target temperature.

**Default**: 1

### cal_syns[#](#cal-syns)

**Type**: Boolean**Description**: Whether the asynchronous overlap matrix is calculated for Hefei-NAMD.**Default**: False

### dmax[#](#dmax)

**Type**: Real**Description**: The maximum displacement of all atoms in one step. This parameter is useful when[cal_syns](#cal-syns)= True.**Default**: 0.01**Unit**: bohr

## DFT+*U* correction[#](#dft-u-correction)

These variables are used to control DFT+U correlated parameters

### dft_plus_u[#](#dft-plus-u)

**Type**: Integer**Description**: Determines whether to calculate the plus U correction, which is especially important for correlated electrons.`onsite_radius`

).0: Do not calculate plus U correction.


**Default**: 0

### orbital_corr[#](#orbital-corr)

**Type**: Integer**Description**: Specifies which orbits need plus U correction for each atom type (\(l_1,l_2,l_3,\ldots\) for atom type 1, 2, 3, respectively).-1: The plus U correction will not be calculated for this atom.

1: For p-electron orbits, the plus U correction is needed.

2: For d-electron orbits, the plus U correction is needed.

3: For f-electron orbits, the plus U correction is needed.


**Default**: -1

### hubbard_u[#](#hubbard-u)

**Type**: Real**Description**: Specifies the Hubbard Coulomb interaction parameter U (eV) in plus U correction, which should be specified for each atom unless the Yukawa potential is used.

**Default**: 0.0

### yukawa_potential[#](#yukawa-potential)

**Type**: Boolean**Description**: Determines whether to use the local screen Coulomb potential method to calculate the values of U and J.True:

`hubbard_u`

does not need to be specified.False:

`hubbard_u`

does need to be specified.

**Default**: False

### yukawa_lambda[#](#yukawa-lambda)

**Type**: Real**Availability**: DFT+U with`yukawa_potential`

= True.**Description**: The screen length of Yukawa potential. If left to default, the screen length will be calculated as an average of the entire system. It’s better to stick to the default setting unless there is a very good reason.**Default**: Calculated on the fly.

### uramping[#](#uramping)

**Type**: Real**Unit**: eV**Availability**: DFT+U calculations with`mixing_restart > 0`

.**Description**: Once`uramping`

> 0.15 eV. DFT+U calculations will start SCF with U = 0 eV, namely normal LDA/PBE calculations. Once SCF restarts when`drho<mixing_restart`

, U value will increase by`uramping`

eV. SCF will repeat above calcuations until U values reach target defined in`hubbard_u`

. As for`uramping=1.0 eV`

, the recommendations of`mixing_restart`

is around`5e-4`

.**Default**: -1.0.

### omc[#](#omc)

**Type**: Integer**Description**: The parameter controls the form of occupation matrix control used.`[initial_onsite.dm](http://initial_onsite.dm/)`

, but for later steps, the onsite density matrix will be updated.`initial_onsite.dm`

will be used throughout the entire calculation.


`initial_onsite.dm`

is to run a DFT+U calculation, look for a file named`onsite.dm`

in the OUT.prefix directory, and make replacements there. The format of the file is rather straight-forward.

**Default**: 0

### onsite_radius[#](#onsite-radius)

**Type**: Real**Availability**:`dft_plus_u`

is set to 1**Description**:`Onsite-radius`

parameter facilitates modulation of the single-zeta portion of numerical atomic orbitals for projections for DFT+U.

\[ \alpha(r) = \frac{\chi(r)g(r;\sigma)}{\langle\chi(r)g(r;\sigma), \chi(r)g(r;\sigma)\rangle} \]To find an appropriate \(\sigma\), the optimization process is as follows:


**Unit**: Bohr**Default**: 3.0

## vdW correction[#](#vdw-correction)

These variables are used to control vdW-corrected related parameters.

### vdw_method[#](#vdw-method)

**Type**: String**Description**: Specifies the method used for Van der Waals (VdW) correction. Available options are:`d2`

:[Grimme’s D2](https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20495)dispersion correction method`d3_0`

:[Grimme’s DFT-D3(0)](https://aip.scitation.org/doi/10.1063/1.3382344)dispersion correction method (zero-damping)`d3_bj`

:[Grimme’s DFTD3(BJ)](https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.21759)dispersion correction method (BJ-damping)`none`

: no vdW correction

**Default**: none**Note**: ABACUS supports automatic setting on DFT-D3 parameters for common functionals after version 3.8.3 (and several develop versions earlier). To benefit from this feature, please specify the parameter`dft_functional`

explicitly (for more details on this parameter, please see[dft_functional](#dft-functional)), otherwise the autoset procedure will crash with error message like`cannot find DFT-D3 parameter for XC(***)`

. If not satisfied with those in-built parameters, any manually setting on`vdw_s6`

,`vdw_s8`

,`vdw_a1`

and`vdw_a2`

will overwrite.**Special**: There are special cases for functional family wB97 (Omega-B97): if want to use the functional wB97X-D3BJ, one needs to specify the`dft_functional`

as`HYB_GGA_WB97X_V`

and`vdw_method`

as`d3_bj`

. If want to use the functional wB97X-D3, specify`dft_functional`

as`HYB_GGA_WB97X_D3`

and`vdw_method`

as`d3_0`

.

### vdw_s6[#](#vdw-s6)

**Type**: Real**Availability**:`vdw_method`

is set to`d2`

,`d3_0`

, or`d3_bj`

**Description**: This scale factor is used to optimize the interaction energy deviations in van der Waals (vdW) corrected calculations. The recommended values of this parameter are dependent on the chosen vdW correction method and the DFT functional being used. For DFT-D2, the recommended values are 0.75 (PBE), 1.2 (BLYP), 1.05 (B-P86), 1.0 (TPSS), and 1.05 (B3LYP). If not set, will use values of PBE functional. For DFT-D3, recommended values with different DFT functionals can be found on the[here](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the`dft_functional`

keywords. User set value will overwrite the searched value.**Default**:0.75: if

`vdw_method`

is set to`d2`



### vdw_s8[#](#vdw-s8)

**Type**: Real**Availability**:`vdw_method`

is set to`d3_0`

or`d3_bj`

**Description**: This scale factor is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the[webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the`dft_functional`

keywords. User set value will overwrite the searched value.

### vdw_a1[#](#vdw-a1)

**Type**: Real**Availability**:`vdw_method`

is set to`d3_0`

or`d3_bj`

**Description**: This damping function parameter is relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the[webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the`dft_functional`

keywords. User set value will overwrite the searched value.

### vdw_a2[#](#vdw-a2)

**Type**: Real**Availability**:`vdw_method`

is set to`d3_0`

or`d3_bj`

**Description**: This damping function parameter is only relevant for D3(0) and D3(BJ) van der Waals (vdW) correction methods. The recommended values of this parameter with different DFT functionals can be found on the[webpage](https://github.com/dftd3/simple-dftd3/blob/main/assets/parameters.toml). If not set, will search in ABACUS built-in dataset based on the`dft_functional`

keywords. User set value will overwrite the searched value.

### vdw_d[#](#vdw-d)

**Type**: Real**Availability**:`vdw_method`

is set to`d2`

**Description**: Controls the damping rate of the damping function in the DFT-D2 method.**Default**: 20

### vdw_abc[#](#vdw-abc)

**Type**: Integer**Availability**:`vdw_method`

is set to`d3_0`

or`d3_bj`

**Description**: Determines whether three-body terms are calculated for DFT-D3 methods.True: ABACUS will calculate the three-body term.

False: The three-body term is not included.


**Default**: False

### vdw_C6_file[#](#vdw-c6-file)

**Type**: String**Availability**:`vdw_method`

is set to`d2`

**Description**: Specifies the name of the file containing \(C_6\) parameters for each element when using the D2 method. If not set, ABACUS uses the default \(C_6\) parameters (Jnm6/mol) stored in the[program](https://github.com/deepmodeling/abacus-develop/blob/develop/source/source_hamilt/module_vdw/vdwd2_parameters.cpp). To manually set the \(C_6\) parameters, provide a file containing the parameters. An example is given by:H 0.1 Si 9.0

Namely, each line contains the element name and the corresponding \(C_6\) parameter.

**Default**: default

### vdw_C6_unit[#](#vdw-c6-unit)

**Type**: String**Availability**:`vdw_C6_file`

is not default**Description**: Specifies the unit of the provided \(C_6\) parameters in the D2 method. Available options are:`Jnm6/mol`

(J·nm^6/mol)`eVA`

(eV·Angstrom)

**Default**: Jnm6/mol

### vdw_R0_file[#](#vdw-r0-file)

**Type**: String**Availability**:`vdw_method`

is set to`d2`

**Description**: Specifies the name of the file containing \(R_0\) parameters for each element when using the D2 method. If not set, ABACUS uses the default \(R_0\) parameters (Angstrom) stored in the[program](https://github.com/deepmodeling/abacus-develop/blob/develop/source/source_hamilt/module_vdw/vdwd2_parameters.cpp). To manually set the \(R_0\) parameters, provide a file containing the parameters. An example is given by:Li 1.0 Cl 2.0

Namely, each line contains the element name and the corresponding \(R_0\) parameter.

**Default**: default

### vdw_R0_unit[#](#vdw-r0-unit)

**Type**: String**Availability**:`vdw_R0_file`

is not default**Description**: Specifies the unit for the \(R_0\) parameters in the D2 method when manually set by the user. Available options are:`A`

(Angstrom)`Bohr`


**Default**: A

### vdw_cutoff_type[#](#vdw-cutoff-type)

**Type**: String**Description**: Determines the method used for specifying the cutoff radius in periodic systems when applying Van der Waals correction. Available options are:`radius`

: The supercell is selected within a sphere centered at the origin with a radius defined by`vdw_cutoff_radius`

.`period`

: The extent of the supercell is explicitly specified using the`vdw_cutoff_period`

keyword.

**Default**: radius

### vdw_cutoff_radius[#](#vdw-cutoff-radius)

**Type**: Real**Availability**:`vdw_cutoff_type`

is set to`radius`

**Description**: Defines the radius of the cutoff sphere when`vdw_cutoff_type`

is set to`radius`

. The default values depend on the chosen`vdw_method`

.**Default**:56.6918 if

`vdw_method`

is set to`d2`

95 if

`vdw_method`

is set to`d3_0`

or`d3_bj`


**Unit**: defined by`vdw_radius_unit`

(default`Bohr`

)

### vdw_radius_unit[#](#vdw-radius-unit)

**Type**: String**Availability**:`vdw_cutoff_type`

is set to`radius`

**Description**: Specify the unit of`vdw_cutoff_radius`

. Available options are:`A`

(Angstrom)`Bohr`


**Default**: Bohr

### vdw_cutoff_period[#](#vdw-cutoff-period)

**Type**: Integer Integer Integer**Availability**:`vdw_cutoff_type`

is set to`period`

**Description**: The three integers supplied here explicitly specify the extent of the supercell in the directions of the three basis lattice vectors.**Default**: 3 3 3

### vdw_cn_thr[#](#vdw-cn-thr)

**Type**: Real**Availability**:`vdw_method`

is set to`d3_0`

or`d3_bj`

**Description**: The cutoff radius when calculating coordination numbers.**Default**: 40**Unit**: defined by`vdw_cn_thr_unit`

(default:`Bohr`

)

### vdw_cn_thr_unit[#](#vdw-cn-thr-unit)

**Type**: String**Description**: Unit of the coordination number cutoff (`vdw_cn_thr`

). Available options are:`A`

(Angstrom)`Bohr`


**Default**: Bohr

## Berry phase and wannier90 interface[#](#berry-phase-and-wannier90-interface)

These variables are used to control berry phase and wannier90 interface parameters. [Detail introduce](https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/interface/Wannier90.md#wannier90)

### berry_phase[#](#berry-phase)

**Type**: Boolean**Description**: Controls the calculation of Berry phasetrue: Calculate Berry phase.

false: Do not calculate Berry phase.


**Default**: false

### gdir[#](#gdir)

**Type**: Integer**Description**: The direction of the polarization in the lattice vector for Berry phase calculation1: Calculate the polarization in the direction of the lattice vector a_1 defined in the STRU file.

2: Calculate the polarization in the direction of the lattice vector a_2 defined in the STRU file.

3: Calculate the polarization in the direction of the lattice vector a_3 defined in the STRU file.


**Default**: 3

### towannier90[#](#towannier90)

**Type**: Integer**Description**: Controls the generation of files for the Wannier90 code.1: Generate files for the Wannier90 code.

0: Do not generate files for the Wannier90 code.


**Default**: 0

### nnkpfile[#](#nnkpfile)

**Type**: String**Description**: The file name generated when running “wannier90 -pp …” command**Default**: seedname.nnkp

### wannier_method[#](#wannier-method)

**Type**: Integer**Description**: Only available on LCAO basis, using different methods to generate “*.mmn” file and “*.amn” file.`lcao_in_pw`

method, the calculation accuracy can be improved by increasing`ecutwfc`

to maintain consistency with the pw basis set results.

**Default**: 1

### wannier_spin[#](#wannier-spin)

**Type**: String**Description**: The spin direction for the Wannier function calculation when nspin is set to 2`up`

: Calculate spin up for the Wannier function.`down`

: Calculate spin down for the Wannier function.

**Default**:`up`


### out_wannier_mmn[#](#out-wannier-mmn)

**Type**: Bool**Description**: Write the “*.mmn” file or not.0: don’t write the “*.mmn” file.

1: write the “*.mmn” file.


**Default**: 1

### out_wannier_amn[#](#out-wannier-amn)

**Type**: Bool**Description**: Write the “*.amn” file or not.0: don’t write the “*.amn” file.

1: write the “*.amn” file.


**Default**: 1

### out_wannier_eig[#](#out-wannier-eig)

**Type**: Bool**Description**: Write the “*.eig” file or not.0: don’t write the “*.eig” file.

1: write the “*.eig” file.


**Default**: 1

### out_wannier_unk[#](#out-wannier-unk)

**Type**: Bool**Description**: Write the “UNK.*” file or not.0: don’t write the “UNK.*” file.

1: write the “UNK.*” file.


**Default**: 0

### out_wannier_wvfn_formatted[#](#out-wannier-wvfn-formatted)

**Type**: Bool**Description**: Write the “UNK.*” file in ASCII format or binary format.0: write the “UNK.*” file in binary format.

1: write the “UNK.*” file in ASCII format (text file format).


**Default**: 1

## RT-TDDFT: Real-Time Time-Dependent Density Functional Theory[#](#rt-tddft-real-time-time-dependent-density-functional-theory)

### estep_per_md[#](#estep-per-md)

**Type**: Integer**Description**: The number of electronic propagation steps between two ionic steps.**Default**: 1

### td_dt[#](#td-dt)

**Type**: Real**Description**: The time step used in electronic propagation. Setting`td_dt`

will reset the value ofto`md_dt`

`td_dt * estep_per_md`

.**Default**:`md_dt / estep_per_md`

**Unit**: fs

### td_edm[#](#td-edm)

**Type**: Integer**Description**: Method to calculate the energy-density matrix, mainly affects the calculation of force and stress.**Default**: 0

### td_print_eij[#](#td-print-eij)

**Type**: Real**Description**: Controls the printing of Hamiltonian matrix elements \(E_{ij}=\Braket{\psi_i|\hat{H}|\psi_j}\).\(<0\): Suppress all \(E_{ij}\) output.

`td_print_eij`

.

**Default**: -1**Unit**: Ry

### td_propagator[#](#td-propagator)

**Type**: Integer**Description**: Methods of electronic propagation: \(\psi_{n\boldsymbol{k}}(\boldsymbol{r},t_2) = U(t_2,t_1) \psi_{n\boldsymbol{k}}(\boldsymbol{r},t_1)\).3: Crank-Nicolson, based on solving linear equation.


**Default**: 0

### td_vext[#](#td-vext)

**Type**: Boolean**Description**:True: Add a laser-material interaction (external electric field).

False: No external electric field.


**Default**: False

### td_vext_dire[#](#td-vext-dire)

**Type**: String**Description**: Specifies the direction(s) of the external electric field when`td_vext`

is enabled. For example,`td_vext_dire 1 2`

indicates that external electric fields are applied to both the x and y directions simultaneously. Electric field parameters can also be written as strings. For example,`td_gauss_phase 0 1.5707963`

indicates that the Gaussian type electric fields in the x and y directions have a phase delay of \(\pi/2\). See below for more electric field parameters.1: The external field direction is along the x-axis.

2: The external field direction is along the y-axis.

3: The external field direction is along the z-axis.


**Default**: 1, which is used in ground-state KSDFT.`efield_dir`


### td_stype[#](#td-stype)

**Type**: Integer**Description**: Type of electric field in the space domain, i.e. the gauge of the electric field.0: Length gauge.

1: Velocity gauge.

2: Hybrid gauge. See

for more information.*J. Chem. Theory Comput.*2025, 21, 3335−3341

**Default**: 0

### td_ttype[#](#td-ttype)

**Type**: String**Description**: Type of electric field in the time domain.0: Gaussian type function:


\[ E(t) = A \cos\left[2\pi f(t-t_0)+\varphi\right]\exp\left[-\frac{(t-t_0)^2}{2\sigma^2}\right] \]1: Trapezoid function:


2: Trigonometric function:


\[ E(t) = A \cos(2\pi f_1 t + \varphi_1) \sin^2(2\pi f_2 t + \varphi_2) \]3: Heaviside step function:


\[\begin{split} E(t) = \begin{cases} A, & t < t_0 \\ 0, & t \geqslant t_0 \end{cases} \end{split}\]**Default**: 0

### td_tstart[#](#td-tstart)

**Type**: Integer**Description**: The initial time step when the time-dependent electric field is activated.**Default**: 1

### td_tend[#](#td-tend)

**Type**: Integer**Description**: The final time step when the time-dependent electric field is deactivated. The field remains active between`td_tstart`

and`td_tend`

.**Default**: 1000

### td_lcut1[#](#td-lcut1)

**Type**: Real**Description**: The lower bound of the interval in the length gauge RT-TDDFT, where \(x\) is the fractional coordinate:**Default**: 0.05

### td_lcut2[#](#td-lcut2)

**Type**: Real**Description**: The upper bound of the interval in the length gauge RT-TDDFT, where \(x\) is the fractional coordinate:**Default**: 0.95

### td_gauss_freq[#](#td-gauss-freq)

**Type**: String**Description**: Frequency \(f\) of the Gaussian type electric field.**Default**: 22.13**Unit**: 1/fs

### td_gauss_phase[#](#td-gauss-phase)

**Type**: String**Description**: Phase \(\varphi\) of the Gaussian type electric field.**Default**: 0.0

### td_gauss_sigma[#](#td-gauss-sigma)

**Type**: String**Description**: Pulse width (standard deviation) \(\sigma\) of the Gaussian type electric field.**Default**: 30.0**Unit**: fs

### td_gauss_t0[#](#td-gauss-t0)

**Type**: String**Description**: Step number of the time center \(t_0\) of the Gaussian type electric field.**Default**: 100

### td_gauss_amp[#](#td-gauss-amp)

**Type**: String**Description**: Amplitude \(A\) of the Gaussian type electric field.**Default**: 0.25**Unit**: V/Å

### td_trape_freq[#](#td-trape-freq)

**Type**: String**Description**: Frequency \(f\) of the trapezoid type electric field.**Default**: 1.60**Unit**: 1/fs

### td_trape_phase[#](#td-trape-phase)

**Type**: String**Description**: Phase \(\varphi\) of the trapezoid type electric field.**Default**: 0.0

### td_trape_t1[#](#td-trape-t1)

**Type**: String**Description**: Step number of the time interval \(t_1\) of the trapezoid type electric field.**Default**: 1875

### td_trape_t2[#](#td-trape-t2)

**Type**: String**Description**: Step number of the time interval \(t_2\) of the trapezoid type electric field.**Default**: 5625

### td_trape_t3[#](#td-trape-t3)

**Type**: String**Description**: Step number of the time interval \(t_3\) of the trapezoid type electric field.**Default**: 7500

### td_trape_amp[#](#td-trape-amp)

**Type**: String**Description**: Amplitude \(A\) of the trapezoid type electric field.**Default**: 2.74**Unit**: V/Å

### td_trigo_freq1[#](#td-trigo-freq1)

**Type**: String**Description**: Frequency \(f_1\) of the trigonometric type electric field.**Default**: 1.164656**Unit**: 1/fs

### td_trigo_freq2[#](#td-trigo-freq2)

**Type**: String**Description**: Frequency \(f_2\) of the trigonometric type electric field.**Default**: 0.029116**Unit**: 1/fs

### td_trigo_phase1[#](#td-trigo-phase1)

**Type**:String**Description**: Phase \(\varphi_1\) of the trigonometric type electric field.**Default**: 0.0

### td_trigo_phase2[#](#td-trigo-phase2)

**Type**: String**Description**: Phase \(\varphi_2\) of the trigonometric type electric field.**Default**: 0.0

### td_trigo_amp[#](#td-trigo-amp)

**Type**: String**Description**: Amplitude \(A\) of the trigonometric type electric field.**Default**: 2.74**Unit**: V/Å

### td_heavi_t0[#](#td-heavi-t0)

**Type**: String**Description**: Step number of the switch time \(t_0\) of the Heaviside type electric field.**Default**: 100

### td_heavi_amp[#](#td-heavi-amp)

**Type**: String**Description**: Amplitude \(A\) of the Heaviside type electric field.**Default**: 1.0**Unit**: V/Å

### out_dipole[#](#out-dipole)

**Type**: Boolean**Description**:True: Output electric dipole moment.

False: Do not output electric dipole moment.


**Default**: False

### out_current[#](#out-current)

**Type**: Boolean**Description**:True: Output current.

False: Do not output current.


**Default**: False

### out_current_k[#](#out-current-k)

**Type**: Boolean**Description**:True: Output current for each k-points separately.

False: Output current in total.


**Default**: False

### out_efield[#](#out-efield)

**Type**: Boolean**Description**: Whether to output the electric field data to files. When enabled, writes real-time electric field values (unit: V/Å) into files named`efield_[num].txt`

, where`[num]`

is the sequential index of the electric field ranges from`0`

to`N-1`

for`N`

configured fields. It is noteworthy that the field type sequence follows, while the direction sequence follows`td_ttype`

.`td_vext_dire`

True: Output electric field.

False: Do not output electric field.


**Default**: False

### out_vecpot[#](#out-vecpot)

**Type**: Boolean**Description**: Output vector potential or not (unit: a.u.).True: Output vector potential into file

`At.dat`

.False: Do not output vector potential.


**Default**: False

### init_vecpot_file[#](#init-vecpot-file)

**Type**: Boolean**Description**: Initialize vector potential through file or not.`At.dat`

(unit: a.u.). It consists of four columns, representing the step number and vector potential on each direction.False: Calculate vector potential by integrating the electric field.


**Default**: False

### ocp[#](#ocp)

**Type**: Boolean**Availability**:For PW and LCAO codes: If enabled, the band occupations will be determined by

`ocp_set`

.For OFDFT: This feature is not available.


**Description**:True: Fixes the band occupations based on the values specified in

`ocp_set`

.False: Does not fix the band occupations.

**Default**: False

### ocp_set[#](#ocp-set)

**Type**: String**Description**:`ocp`

is set to 1,`ocp_set`

must be provided as a string specifying the occupation numbers for each band across all k-points. The format follows a space-separated pattern, where occupations are assigned sequentially to bands for each k-point. A shorthand notation`N*x`

can be used to repeat a value`x`

for`N`

bands.Example:

`1 10*1 0 1`

represents occupations for 13 bands, where the 12th band is fully unoccupied (`0`

), and all others are occupied (`1`

).

`ocp_set`

could lead to inconsistencies in electron counting, causing the calculation to terminate with an error.

**Default**: None

## Variables useful for debugging[#](#variables-useful-for-debugging)

### t_in_h[#](#t-in-h)

**Type**: Boolean**Description**: Specify whether to include kinetic term in obtaining the Hamiltonian matrix.0: No.

1: Yes.


**Default**: 1

### vl_in_h[#](#vl-in-h)

**Type**: Boolean**Description**: Specify whether to include local pseudopotential term in obtaining the Hamiltonian matrix.0: No.

1: Yes.


**Default**: 1

### vnl_in_h[#](#vnl-in-h)

**Type**: Boolean**Description**: Specify whether to include non-local pseudopotential term in obtaining the Hamiltonian matrix.0: No.

1: Yes.


**Default**: 1

### vh_in_h[#](#vh-in-h)

**Type**: Boolean**Description**: Specify whether to include Hartree potential term in obtaining the Hamiltonian matrix.0: No.

1: Yes.


**Default**: 1

### vion_in_h[#](#vion-in-h)

**Type**: Boolean**Description**: Specify whether to include local ionic potential term in obtaining the Hamiltonian matrix.0: No.

1: Yes.


**Default**: 1

### test_force[#](#test-force)

**Type**: Boolean**Description**: Specify whether to output the detailed components in forces.0: No.

1: Yes.


**Default**: 0

### test_stress[#](#test-stress)

**Type**: Boolean**Description**: Specify whether to output the detailed components in stress.0: No.

1: Yes.


**Default**: 0

### test_skip_ewald[#](#test-skip-ewald)

**Type**: Boolean**Description**: Specify whether to skip the calculation of the ewald energy.0: No.

1: Yes.


**Default**: 0

## Electronic conductivities[#](#electronic-conductivities)

Onsager coefficients:

\(L_{mn}(\omega)=(-1)^{m+n}\frac{2\pi e^2\hbar^2}{3m_e^2\omega\Omega}\)

They can also be computed by \(j\)-\(j\) correlation function.

where \(j_1\) is electric flux and \(j_2\) is thermal flux.

Frequency-dependent electric conductivities: \(\sigma(\omega)=L_{11}(\omega)\).

DC electric conductivities: \(\sigma = \lim_{\omega\to 0}\sigma(\omega)\).

Thermal conductivities: \(\kappa = \lim_{\omega\to 0}\kappa(\omega)\).

### cal_cond[#](#cal-cond)

**Type**: Boolean**Availability**:[basis_type](#basis-type)=`pw`

**Description**: Whether to calculate electronic conductivities.**Default**: False

### cond_che_thr[#](#cond-che-thr)

**Type**: Real**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: Control the error of Chebyshev expansions for conductivities.**Default**: 1e-8

### cond_dw[#](#cond-dw)

**Type**: Real**Availability**:[basis_type](#basis-type)=`pw`

**Description**: Frequency interval (\(\mathrm{d}\omega\)) for frequency-dependent conductivities.**Default**: 0.1**Unit**: eV

### cond_wcut[#](#cond-wcut)

**Type**: Real**Availability**:[basis_type](#basis-type)=`pw`

**Description**: Cutoff frequency for frequency-dependent conductivities.**Default**: 10.0**Unit**: eV

### cond_dt[#](#cond-dt)

**Type**: Real**Availability**:[basis_type](#basis-type)=`pw`

**Description**: Time interval (\(\mathrm{d}t\)) to integrate Onsager coefficients.**Default**: 0.02**Unit**: a.u.

### cond_dtbatch[#](#cond-dtbatch)

**Type**: Integer**Availability**:[esolver_type](#esolver-type)=`sdft`

**Description**: exp(iH*dt*cond_dtbatch) is expanded with Chebyshev expansion to calculate conductivities. It is faster but costs more memory.If

`cond_dtbatch = 0`

: Autoset this parameter to make expansion orders larger than 100.

**Default**: 0

### cond_smear[#](#cond-smear)

**Type**: Integer**Description**: Smearing method for conductivities1: Gaussian smearing

2: Lorentzian smearing


**Default**: 1

### cond_fwhm[#](#cond-fwhm)

**Type**: Real**Availability**:[basis_type](#basis-type)=`pw`

**Description**: FWHM for conductivities. For Gaussian smearing, \(\mathrm{FWHM}=2\sqrt{2\ln2}s\); for Lorentzian smearing, \(\mathrm{FWHM}=2\gamma\).**Default**: 0.4**Unit**: eV

### cond_nonlocal[#](#cond-nonlocal)

**Type**: Boolean**Availability**:[basis_type](#basis-type)=`pw`

**Description**: Whether to consider nonlocal potential correction when calculating velocity matrix \(\bra{\psi_i}\hat{v}\ket{\psi_j}\).True: \(m\hat{v}=\hat{p}+\frac{im}{\hbar}[\hat{V}_{NL},\hat{r}]\).

False: \(m\hat{v}\approx\hat{p}\).


**Default**: True

## Implicit solvation model[#](#implicit-solvation-model)

### imp_sol[#](#imp-sol)

**Type**: Boolean**Description**: Calculate implicit solvation correction**Default**: False

### eb_k[#](#eb-k)

**Type**: Real**Availability**:`imp_sol`

is true.**Description**: The relative permittivity of the bulk solvent, 80 for water**Default**: 80

### tau[#](#tau)

**Type**: Real**Description**: The effective surface tension parameter that describes the cavitation, the dispersion, and the repulsion interaction between the solute and the solvent which are not captured by the electrostatic terms**Default**: 1.0798e-05**Unit**: \(Ry/Bohr^{2}\)

### sigma_k[#](#sigma-k)

**Type**: Real**Description**: The width of the diffuse cavity that is implicitly determined by the electronic structure of the solute**Default**: 0.6

### nc_k[#](#nc-k)

**Type**: Real**Description**: The value of the electron density at which the dielectric cavity forms**Default**: 0.00037**Unit**: \(Bohr^{-3}\)

## Quasiatomic Orbital (QO) analysis (Under Development Feature)[#](#quasiatomic-orbital-qo-analysis-under-development-feature)

### qo_switch (Under Development Feature)[#](#qo-switch-under-development-feature)

**Type**: Boolean**Description**: Whether to let ABACUS output QO analysis required files**Default**: 0

### qo_basis (Under Development Feature)[#](#qo-basis-under-development-feature)

**Type**: String**Description**: Specify the type of atomic basis`pswfc`

: use the pseudowavefunction in pseudopotential files as atomic basis. To use this option, please make sure in pseudopotential file there is pswfc in it.`hydrogen`

: generate hydrogen-like atomic basis (or with Slater screening).`szv`

: use the first set of zeta for each angular momentum from numerical atomic orbitals as atomic basis.

*warning: to use*`pswfc`

`szv`

instead of`pswfc`

which is originally put forward in work of QO implementation on PW basis. The information loss always happens if`pswfc`

or`hydrogen`

orbitals are not well tuned, although making kpoints sampling more dense will mitigate this problem, but orbital-adjust parameters are needed to test system-by-system in this case.**Default**:`szv`


### qo_strategy (Under Development Feature)[#](#qo-strategy-under-development-feature)

**Type**: String [String…](optional)**Description**: Specify the strategy to generate radial orbitals for each atom type. If one parameter is given, will apply to all atom types. If more than one parameters are given but fewer than number of atom type, those unspecified atom type will use default value.For

`qo_basis hydrogen`

`minimal-nodeless`

: according to principle quantum number of the highest occupied state, generate only nodeless orbitals, for example Cu, only generate 1s, 2p, 3d and 4f orbitals (for Cu, 4s is occupied, thus \(n_{max} = 4\))`minimal-valence`

: according to principle quantum number of the highest occupied state, generate only orbitals with highest principle quantum number, for example Cu, only generate 4s, 4p, 4d and 4f orbitals.`full`

: similarly according to the maximal principle quantum number, generate all possible orbitals, therefore for Cu, for example, will generate 1s, 2s, 2p, 3s, 3p, 3d, 4s, 4p, 4d, 4f.`energy-full`

: will generate hydrogen-like orbitals according to Aufbau principle. For example the Cu (1s2 2s2 2p6 3s2 3p6 3d10 4s1), will generate these orbitals.`energy-valence`

: from the highest n (principal quantum number) layer and n-1 layer, generate all occupied and possible ls (angular momentum quantum number) for only once, for example Cu, will generate 4s, 3d and 3p orbitals.

For

`qo_basis pswfc`

and`qo_basis szv`

`all`

: use all possible pseudowavefunctions/numerical atomic orbital (of first zeta) in pseudopotential/numerical atomic orbital file.`s`

/`p`

/`d`

/…: only use s/p/d/f/…-orbital(s).`spd`

: use s, p and d orbital(s). Any unordered combination is acceptable.

*warning: for*`qo_basis hydrogen`

*to use*`full`

,**Default**: for`hydrogen`

:`energy-valence`

, for`pswfc`

and`szv`

:`all`


### qo_screening_coeff (Under Development Feature)[#](#qo-screening-coeff-under-development-feature)

**Type**: Real [Real…](optional)**Description**: rescale the shape of radial orbitals, available for both`qo_basis hydrogen`

and`qo_basis pswfc`

. cases but has different meaning.`qo_basis pswfc`

For each atom type, screening factor \(e^{-\eta|\mathbf{r}|}\) is multiplied to the pswfc to mimic the behavior of some kind of electron. \(\eta\) is the screening coefficient. If only one value is given, then will apply to each atom type. If not enough values are given, will apply default value to rest of atom types. This parameter plays important role in controlling the spread of QO orbitals together with`qo_thr`

.`qo_basis hydrogen`

If any float number is given, will apply Slater screening to all atom types. Slater screening is a classic and empirical method roughly taking many-electron effect into account for obtaining more accurate results when evaluating electron affinity and ionization energy. The Coulomb potential then becomes \(V(r) = -\frac{Z-\sigma}{r}\). For example the effective nuclear charge for Cu 3d electrons now reduces from 29 to 7.85, 4s from 29 to 3.70, which means Slater screening will bring about longer tailing effect. If no value is given, will not apply Slater screening.**Default**: 0.1**Unit**: Bohr^-1

### qo_thr (Under Development Feature)[#](#qo-thr-under-development-feature)

**Type**: Real**Description**: The convergence threshold determining the cutoff of generated orbital. Lower threshold will yield orbital with larger cutoff radius.**Default**: 1.0e-6

## PEXSI[#](#pexsi)

### pexsi_npole[#](#pexsi-npole)

**Type**: Integer**Description**: The number of poles used in the pole expansion method, should be a even number.**Default**: 40

### pexsi_inertia[#](#pexsi-inertia)

**Type**: Boolean**Description**: Whether inertia counting is used at the very beginning.**Default**: True

### pexsi_nmax[#](#pexsi-nmax)

**Type**: Integer**Description**: Maximum number of PEXSI iterations after each inertia counting procedure.**Default**: 80

### pexsi_comm[#](#pexsi-comm)

**Type**: Boolean**Description**: Whether to construct PSelInv communication pattern.**Default**: True

### pexsi_storage[#](#pexsi-storage)

**Type**: Boolean**Description**: Whether to use symmetric storage space used by the Selected Inversion algorithm for symmetric matrices.**Default**: True

### pexsi_ordering[#](#pexsi-ordering)

**Type**: Integer**Description**: Ordering strategy for factorization and selected inversion. 0: Parallel ordering using ParMETIS, 1: Sequential ordering using METIS, 2: Multiple minimum degree ordering**Default**: 0

### pexsi_row_ordering[#](#pexsi-row-ordering)

**Type**: Integer**Description**: Row permutation strategy for factorization and selected inversion, 0: No row permutation, 1: Make the diagonal entry of the matrix larger than the off-diagonal entries.**Default**: 1

### pexsi_nproc[#](#pexsi-nproc)

**Type**: Integer**Description**: Number of processors for PARMETIS. Only used if pexsi_ordering == 0.**Default**: 1

### pexsi_symm[#](#pexsi-symm)

**Type**: Boolean**Description**: Whether the matrix is symmetric.**Default**: True

### pexsi_trans[#](#pexsi-trans)

**Type**: Boolean**Description**: Whether to factorize the transpose of the matrix.**Default**: False

### pexsi_method[#](#pexsi-method)

**Type**: Integer**Description**: The pole expansion method to be used. 1 for Cauchy Contour Integral method, 2 for Moussa optimized method.**Default**: 1

### pexsi_nproc_pole[#](#pexsi-nproc-pole)

**Type**: Integer**Description**: The point parallelizaion of PEXSI. Recommend two points parallelization.**Default**: 1

### pexsi_temp[#](#pexsi-temp)

**Type**: Real**Description**: Temperature in Fermi-Dirac distribution, in Ry, should have the same effect as the smearing sigma when smearing method is set to Fermi-Dirac.**Default**: 0.015

### pexsi_gap[#](#pexsi-gap)

**Type**: Real**Description**: Spectral gap, this can be set to be 0 in most cases.**Default**: 0

### pexsi_delta_e[#](#pexsi-delta-e)

**Type**: Real**Description**: Upper bound for the spectral radius of \(S^{-1} H\).**Default**: 20

### pexsi_mu_lower[#](#pexsi-mu-lower)

**Type**: Real**Description**: Initial guess of lower bound for mu.**Default**: -10

### pexsi_mu_upper[#](#pexsi-mu-upper)

**Type**: Real**Description**: Initial guess of upper bound for mu.**Default**: 10

### pexsi_mu[#](#pexsi-mu)

**Type**: Real**Description**: Initial guess for mu (for the solver).**Default**: 0

### pexsi_mu_thr[#](#pexsi-mu-thr)

**Type**: Real**Description**: Stopping criterion in terms of the chemical potential for the inertia counting procedure.**Default**: 0.05

### pexsi_mu_expand[#](#pexsi-mu-expand)

**Type**: Real**Description**: If the chemical potential is not in the initial interval, the interval is expanded by this value.**Default**: 0.3

### pexsi_mu_guard[#](#pexsi-mu-guard)

**Type**: Real**Description**: Safe guard criterion in terms of the chemical potential to reinvoke the inertia counting procedure.**Default**: 0.2

### pexsi_elec_thr[#](#pexsi-elec-thr)

**Type**: Real**Description**: Stopping criterion of the PEXSI iteration in terms of the number of electrons compared to numElectronExact.**Default**: 0.001

### pexsi_zero_thr[#](#pexsi-zero-thr)

**Type**: Real**Description**: if the absolute value of CCS matrix element is less than this value, it will be considered as zero.**Default**: 1e-10

## Linear Response TDDFT (Under Development Feature)[#](#linear-response-tddft-under-development-feature)

These parameters are used to solve the excited states using. e.g. LR-TDDFT.

### xc_kernel (Under Development Feature)[#](#xc-kernel-under-development-feature)

**Type**: String**Description**: The exchange-correlation kernel used in the calculation. Currently supported:`RPA`

,`LDA`

,`PBE`

,`HSE`

,`HF`

.**Default**: LDA

### lr_init_xc_kernel (Under Development Feature)[#](#lr-init-xc-kernel-under-development-feature)

**Type**: String**Description**: The method to initalize the xc kernel.“default”: Calculate xc kerenel (\(f_\text{xc}\)) from the ground-state charge density.

) or 3 ([nspin](#nspin)==1, namely spin-aa, spin-ab and spin-bb) will be read in. The parameter[nspin](#nspin)==2[xc_kernel](#xc_kernel)will be invalid. Now only LDA-type kernel is supproted as the potential will be calculated by directly multiplying the transition density.[nspin](#$nspin)files will be read in.

**Default**: “default”

### lr_solver (Under Development Feature)[#](#lr-solver-under-development-feature)

**Type**: String**Description**: The method to solve the Casida equation \(AX=\Omega X\) in LR-TDDFT under Tamm-Dancoff approximation (TDA), where \(A_{ai,bj}=(\epsilon_a-\epsilon_i)\delta_{ij}\delta_{ab}+(ai|f_{Hxc}|bj)+\alpha_{EX}(ab|ij)\) is the particle-hole excitation matrix and \(X\) is the transition amplitude.`dav`

/`dav_subspace`

/`cg`

: Construct \(AX\) and diagonalize the Hamiltonian matrix iteratively with Davidson/Non-ortho-Davidson/CG algorithm.`lapack`

: Construct the full \(A\) matrix and directly diagonalize with LAPACK.`spectrum`

: Calculate absorption spectrum only without solving Casida equation. The`OUT.${suffix}/`

directory should contain the files for LR-TDDFT eigenstates and eigenvalues, i.e.`Excitation_Energy.dat`

and`Excitation_Amplitude_${processor_rank}.dat`

output by setting`out_wfc_lr`

to true.

**Default**: dav

### lr_thr (Under Development Feature)[#](#lr-thr-under-development-feature)

**Type**: Real**Description**: The convergence threshold of iterative diagonalization solver fo LR-TDDFT. It is a pure-math number with the same as[pw_diag_thr](#pw-diag-thr), but since the Casida equation is a one-shot eigenvalue problem, it is also the convergence threshold of LR-TDDFT.**Default**: 1e-2

### nocc (Under Development Feature)[#](#nocc-under-development-feature)

### nvirt (Under Development Feature)[#](#nvirt-under-development-feature)

**Type**: Integer**Description**: The number of virtual orbitals (staring from LUMO) used in the LR-TDDFT calculation.**Default**: 1

### lr_nstates (Under Development Feature)[#](#lr-nstates-under-development-feature)

**Type**: Integer**Description**: The number of 2-particle states to be solved**Default**: 0

### lr_unrestricted (Under Development Feature)[#](#lr-unrestricted-under-development-feature)

**Type**: Boolean**Description**: Whether to use unrestricted construction for LR-TDDFT (the matrix size will be doubled).True: Always use unrestricted LR-TDDFT.

False: Use unrestricted LR-TDDFT only when the system is open-shell.


**Default**: False

### abs_wavelen_range (Under Development Feature)[#](#abs-wavelen-range-under-development-feature)

**Type**: Real Real**Description**: The range of the wavelength for the absorption spectrum calculation.**Default**: 0.0 0.0

### out_wfc_lr (Under Development Feature)[#](#out-wfc-lr-under-development-feature)

**Type**: Boolean**Description**: Whether to output the eigenstates (excitation energy) and eigenvectors (excitation amplitude) of the LR-TDDFT calculation. The output files are`OUT.${suffix}/Excitation_Energy.dat`

and`OUT.${suffix}/Excitation_Amplitude_${processor_rank}.dat`

.**Default**: False

### abs_broadening (Under Development Feature)[#](#abs-broadening-under-development-feature)

**Type**: Real**Description**: The broadening factor \(\eta\) for the absorption spectrum calculation.**Default**: 0.01

### ri_hartree_benchmark (Under Development Feature)[#](#ri-hartree-benchmark-under-development-feature)

**Type**: String**Description**: Whether to use the localized resolution-of-identity (LRI) approximation for the**Hartree**term of kernel in the \(A\) matrix of LR-TDDFT for benchmark (with FHI-aims or another ABACUS calculation). Now it only supports molecular systems running with a single processor, and a large enough supercell should be used to make LRI C, V tensors contain only the R=(0 0 0) cell.`aims`

: The`OUT.${suffix}`

directory should contain the FHI-aims output files: RI-LVL tensors`Cs_data_0.txt`

and`coulomb_mat_0.txt`

, and KS eigenstates from FHI-aims:`band_out`

and`KS_eigenvectors.out`

. The Casida equation will be constructed under FHI-aims’ KS eigenpairs.`Cs_data_0.txt`

and`coulomb_mat_0.txt`

)and Kohn-Sham eigenvalues (`bands_out`

): run FHI-aims with periodic boundary conditions and with`total_energy_method rpa`

and`output librpa`

.`KS_eigenvectors.out`

): run FHI-aims with`output eigenvectors`

.`aims_nbasis`

should be set.

`abacus`

: The`OUT.${suffix}`

directory should contain the RI-LVL tensors`Cs`

and`Vs`

(written by setting`out_ri_cv`

to 1). The Casida equation will be constructed under ABACUS’ KS eigenpairs, with the only difference that the Hartree term is constructed with RI approximation.`none`

: Construct the Hartree term by Poisson equation and grid integration as usual.

**Default**: none

### aims_nbasis (Under Development Feature)[#](#aims-nbasis-under-development-feature)

**Type**: A number(ntype) of Integers**Availability**:`ri_hartree_benchmark`

=`aims`

**Description**: Atomic basis set size for each atom type (with the same order as in`STRU`

) in FHI-aims.**Default**: {} (empty list, where ABACUS use its own basis set size)

## Reduced Density Matrix Functional Theory (Under Development Feature)[#](#reduced-density-matrix-functional-theory-under-development-feature)

### rdmft (Under Development Feature)[#](#rdmft-under-development-feature)

**Type**: Boolean**Description**: Whether to perform rdmft calculation (reduced density matrix funcional theory)**Default**: false

### rdmft_power_alpha (Under Development Feature)[#](#rdmft-power-alpha-under-development-feature)

**Type**: Real**Description**: The alpha parameter of power-functional(or other exx-type/hybrid functionals) which used in RDMFT, g(occ_number) = occ_number^alpha**Default**: 0.656
